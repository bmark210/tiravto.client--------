//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
  providedIn: 'root'
})
export class Client {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://shopapi.tiravto.com";
    }

    /**
     * Авторизация в админ панель
     * @param model Модель данных (логин, пароль)
     * @return Access token. refresh token
     */
    account_LoginAdmin(model: LoginRequest): Observable<LoginResponse> {
        let url_ = this.baseUrl + "/api/Account/LoginAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccount_LoginAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccount_LoginAdmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResponse>;
        }));
    }

    protected processAccount_LoginAdmin(response: HttpResponseBase): Observable<LoginResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoginResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Авторизация
     * @param model Модель данных (логин, пароль)
     * @return Access token. refresh token
     */
    account_Login(model: LoginRequest): Observable<LoginResponse> {
        let url_ = this.baseUrl + "/api/Account/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccount_Login(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccount_Login(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResponse>;
        }));
    }

    protected processAccount_Login(response: HttpResponseBase): Observable<LoginResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoginResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Восстановление пароля
     * @param binding Биндинг восстановления пароля
     * @return Access token. refresh token
     */
    account_RestorePas(binding: RestorePasswordRequest): Observable<string> {
        let url_ = this.baseUrl + "/api/Account/password/restore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccount_RestorePas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccount_RestorePas(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processAccount_RestorePas(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("A server side error occurred.", status, _responseText, _headers, result429);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Восстановление пароля
     * @param binding Биндинг восстановления пароля
     * @return Access token. refresh token
     */
    account_ChangePas(binding: ChangePasswordRequest): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Account/password/change";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccount_ChangePas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccount_ChangePas(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAccount_ChangePas(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Регистрация пользователя
     */
    account_Registration(binding: RegisterUserRequest): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Account/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccount_Registration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccount_Registration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAccount_Registration(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить информацию для регистрации
     */
    account_GetRegisterInfo(): Observable<RegisterHelperResponse> {
        let url_ = this.baseUrl + "/api/Account/register";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccount_GetRegisterInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccount_GetRegisterInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterHelperResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterHelperResponse>;
        }));
    }

    protected processAccount_GetRegisterInfo(response: HttpResponseBase): Observable<RegisterHelperResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegisterHelperResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получение нового Access-токена на основе refresh и access-токена
     */
    account_RefreshToken(request: ExchangeRefreshTokenRequest): Observable<ExchangeRefreshTokenResponse> {
        let url_ = this.baseUrl + "/api/Account/refreshtoken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccount_RefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccount_RefreshToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExchangeRefreshTokenResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExchangeRefreshTokenResponse>;
        }));
    }

    protected processAccount_RefreshToken(response: HttpResponseBase): Observable<ExchangeRefreshTokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ExchangeRefreshTokenResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Завершение сессии пользователя (выход)
     */
    account_LogOut(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Account/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccount_LogOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccount_LogOut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAccount_LogOut(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить баланс
     */
    account_UserBalance(): Observable<number> {
        let url_ = this.baseUrl + "/api/Account/user/balance";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccount_UserBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccount_UserBalance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processAccount_UserBalance(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Обновить баланс (1C)
     */
    account_UserBalanceUpdate(binding: UserBalanceRequest[]): Observable<boolean> {
        let url_ = this.baseUrl + "/user/balance";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccount_UserBalanceUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccount_UserBalanceUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAccount_UserBalanceUpdate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Обновление с сайта
     */
    account_UpdateUser(binding: UserProfileInfoEditRequest): Observable<UserProfileInfoEditResponse> {
        let url_ = this.baseUrl + "/api/Account/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccount_UpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccount_UpdateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileInfoEditResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileInfoEditResponse>;
        }));
    }

    protected processAccount_UpdateUser(response: HttpResponseBase): Observable<UserProfileInfoEditResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserProfileInfoEditResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Обновление с сайта адресов
     */
    account_UpdateUserAddresses(binding: UserAddressRequest): Observable<UserAddressResponse[]> {
        let url_ = this.baseUrl + "/api/Account/users/address";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccount_UpdateUserAddresses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccount_UpdateUserAddresses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserAddressResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserAddressResponse[]>;
        }));
    }

    protected processAccount_UpdateUserAddresses(response: HttpResponseBase): Observable<UserAddressResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserAddressResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Тест Смс сервиса
     * @param to (optional) Номер телефона получателя (37300011122)
     * @param text (optional) Текст SMS-сообщения
     */
    account_SendSms(to: string | null | undefined, text: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Account/SMS?";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        if (text !== undefined && text !== null)
            url_ += "text=" + encodeURIComponent("" + text) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccount_SendSms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccount_SendSms(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processAccount_SendSms(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Добавление или обновление пользователя (1C)
     * @param binding Биндинг
     */
    account_AddOrUpdate(binding: RegisterUser1CRequest): Observable<boolean> {
        let url_ = this.baseUrl + "/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccount_AddOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccount_AddOrUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAccount_AddOrUpdate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Создание запроса по сверке
     * @param binding Биндинг
     */
    account_AddUserAccounting(binding: UserAccountingRequest): Observable<UserAccountingHelper> {
        let url_ = this.baseUrl + "/users/accounting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccount_AddUserAccounting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccount_AddUserAccounting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserAccountingHelper>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserAccountingHelper>;
        }));
    }

    protected processAccount_AddUserAccounting(response: HttpResponseBase): Observable<UserAccountingHelper> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserAccountingHelper;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить сверки
     */
    account_UserAccounting(): Observable<UserAccountingResponseHelper> {
        let url_ = this.baseUrl + "/users/accounting";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccount_UserAccounting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccount_UserAccounting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserAccountingResponseHelper>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserAccountingResponseHelper>;
        }));
    }

    protected processAccount_UserAccounting(response: HttpResponseBase): Observable<UserAccountingResponseHelper> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserAccountingResponseHelper;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Новые сверки
     */
    account_NewAccounting(): Observable<UserAccountingResponse[]> {
        let url_ = this.baseUrl + "/users/accounting/new";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccount_NewAccounting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccount_NewAccounting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserAccountingResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserAccountingResponse[]>;
        }));
    }

    protected processAccount_NewAccounting(response: HttpResponseBase): Observable<UserAccountingResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserAccountingResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить новые сообщения
     */
    chat1C_Upload(): Observable<Chat1CResponse[]> {
        let url_ = this.baseUrl + "/messages/new";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChat1C_Upload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChat1C_Upload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Chat1CResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Chat1CResponse[]>;
        }));
    }

    protected processChat1C_Upload(response: HttpResponseBase): Observable<Chat1CResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Chat1CResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Рассылка
     */
    chat1C_Mailing(binding: UserMailingRequest): Observable<boolean> {
        let url_ = this.baseUrl + "/messages/mailing";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChat1C_Mailing(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChat1C_Mailing(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processChat1C_Mailing(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    file_GetTecDocImagesTask(image: string | null | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/File/tecdocimages?";
        if (image !== undefined && image !== null)
            url_ += "image=" + encodeURIComponent("" + image) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFile_GetTecDocImagesTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFile_GetTecDocImagesTask(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processFile_GetTecDocImagesTask(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    file_GetImagesTask(remoteFile: string | null | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/File/FtpImage?";
        if (remoteFile !== undefined && remoteFile !== null)
            url_ += "remoteFile=" + encodeURIComponent("" + remoteFile) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFile_GetImagesTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFile_GetImagesTask(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processFile_GetImagesTask(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Загрузка файлов
     * @param productOrCategoryId1C (optional)
     * @param mainImageName (optional)
     * @param images (optional)
     * @param imageType (optional)
     */
    file_Upload(productOrCategoryId1C: string | null | undefined, mainImageName: string | null | undefined, images: FileParameter[] | null | undefined, imageType: ImageTypeEnum | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/images";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (productOrCategoryId1C !== null && productOrCategoryId1C !== undefined)
            content_.append("ProductOrCategoryId1C", productOrCategoryId1C.toString());
        if (mainImageName !== null && mainImageName !== undefined)
            content_.append("MainImageName", mainImageName.toString());
        if (images !== null && images !== undefined)
            images.forEach(item_ => content_.append("Images", item_.data, item_.fileName ? item_.fileName : "Images") );
        if (imageType === null || imageType === undefined)
            throw new Error("The parameter 'imageType' cannot be null.");
        else
            content_.append("ImageType", imageType.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFile_Upload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFile_Upload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processFile_Upload(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Удаление файла
     * @param binding Список идентификаторов 1с товаров
     */
    file_DeleteImage(binding: ProductFileDeleteRequest[]): Observable<boolean> {
        let url_ = this.baseUrl + "/images";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFile_DeleteImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFile_DeleteImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processFile_DeleteImage(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Отчет по заказу
     */
    file_OrderDownload(binding: OrderReportRequest): Observable<boolean> {
        let url_ = this.baseUrl + "/orders/download";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFile_OrderDownload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFile_OrderDownload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processFile_OrderDownload(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Получение оплат, которых нет в 1С
     */
    invoice_GetNewList(): Observable<Invoice1C[]> {
        let url_ = this.baseUrl + "/api/Invoice/newList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoice_GetNewList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoice_GetNewList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Invoice1C[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Invoice1C[]>;
        }));
    }

    protected processInvoice_GetNewList(response: HttpResponseBase): Observable<Invoice1C[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Invoice1C[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить оплату по Id
     * @param id (optional)
     */
    invoice_GetInvoiceById(id: number | undefined): Observable<Invoice1C> {
        let url_ = this.baseUrl + "/api/Invoice?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoice_GetInvoiceById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoice_GetInvoiceById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Invoice1C>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Invoice1C>;
        }));
    }

    protected processInvoice_GetInvoiceById(response: HttpResponseBase): Observable<Invoice1C> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Invoice1C;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Изменение статуса 1С
     * @param id Номер счета
     * @return Результат
     */
    invoice_UpdateStatus(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Invoice/updatestatus/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoice_UpdateStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoice_UpdateStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processInvoice_UpdateStatus(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Добавление или обновление заказов
     * @param binding Биндинг
     */
    order_Add1C(binding: OrderRequest1C[]): Observable<boolean> {
        let url_ = this.baseUrl + "/orders/1c";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrder_Add1C(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrder_Add1C(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processOrder_Add1C(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получение заказов, которых нет в 1С
     */
    order_Empty1CAll(): Observable<OrderResponse[]> {
        let url_ = this.baseUrl + "/orders/1c/empty";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrder_Empty1CAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrder_Empty1CAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderResponse[]>;
        }));
    }

    protected processOrder_Empty1CAll(response: HttpResponseBase): Observable<OrderResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Добавление или обновлени заказов
     * @param binding Биндинг
     */
    order_Empty1C(binding: OrderEmptyId1CRequest[]): Observable<boolean> {
        let url_ = this.baseUrl + "/orders/1c/empty";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrder_Empty1C(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrder_Empty1C(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processOrder_Empty1C(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получение заказов, которых нет в 1С по листу ид1с складов
     * @param ids1c Лист ид1с
     */
    order_Empty1CByStoreIds(ids1c: string[]): Observable<OrderResponse[]> {
        let url_ = this.baseUrl + "/orders/1c/emptybystore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids1c);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrder_Empty1CByStoreIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrder_Empty1CByStoreIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderResponse[]>;
        }));
    }

    protected processOrder_Empty1CByStoreIds(response: HttpResponseBase): Observable<OrderResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Быстрый заказ
     */
    order_AddQuick(binding: QuickOrderRequest): Observable<OrderResponse> {
        let url_ = this.baseUrl + "/orders/quick";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrder_AddQuick(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrder_AddQuick(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderResponse>;
        }));
    }

    protected processOrder_AddQuick(response: HttpResponseBase): Observable<OrderResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Все заказы по типу
     * @param type 0 - заказ, 1 - быстрый заказ
     */
    order_GetQuick(type: OrderNumberType): Observable<OrderResponse[]> {
        let url_ = this.baseUrl + "/orders/{type}";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrder_GetQuick(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrder_GetQuick(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderResponse[]>;
        }));
    }

    protected processOrder_GetQuick(response: HttpResponseBase): Observable<OrderResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Инфо для быстрого заказа
     */
    order_QuickOrderInfo(binding: BasketRequest[]): Observable<QuickOrderResponse> {
        let url_ = this.baseUrl + "/orders/quick/info";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrder_QuickOrderInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrder_QuickOrderInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QuickOrderResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QuickOrderResponse>;
        }));
    }

    protected processOrder_QuickOrderInfo(response: HttpResponseBase): Observable<QuickOrderResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as QuickOrderResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Добавление заказа
     */
    order_AddOrder(binding: OrderRequest): Observable<OrderBasketCounterResponse> {
        let url_ = this.baseUrl + "/orders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrder_AddOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrder_AddOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderBasketCounterResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderBasketCounterResponse>;
        }));
    }

    protected processOrder_AddOrder(response: HttpResponseBase): Observable<OrderBasketCounterResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderBasketCounterResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получение всех заказанных товаров пользователя
     */
    order_UserOrdersProducts(request: OrdersProductsRequest): Observable<OrdersProductsPositionResponse> {
        let url_ = this.baseUrl + "/orders/products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrder_UserOrdersProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrder_UserOrdersProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrdersProductsPositionResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrdersProductsPositionResponse>;
        }));
    }

    protected processOrder_UserOrdersProducts(response: HttpResponseBase): Observable<OrdersProductsPositionResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrdersProductsPositionResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получение заказов пользователя
     */
    order_UserOrders(): Observable<OrderResponse[]> {
        let url_ = this.baseUrl + "/orders/user";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrder_UserOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrder_UserOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderResponse[]>;
        }));
    }

    protected processOrder_UserOrders(response: HttpResponseBase): Observable<OrderResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получение заказов пользователя ввиде постранички
     */
    order_PaggingUserOrders(request: OrdersRequest): Observable<OrdersResponse> {
        let url_ = this.baseUrl + "/ordersPagging/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrder_PaggingUserOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrder_PaggingUserOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrdersResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrdersResponse>;
        }));
    }

    protected processOrder_PaggingUserOrders(response: HttpResponseBase): Observable<OrdersResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrdersResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получение заказа пользователя
     */
    order_UserOrderById(id: number): Observable<OrderResponse> {
        let url_ = this.baseUrl + "/orders/user/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrder_UserOrderById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrder_UserOrderById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderResponse>;
        }));
    }

    protected processOrder_UserOrderById(response: HttpResponseBase): Observable<OrderResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    payment_Result(status: string | null | undefined, invoiceid: number | undefined, paymentsum: string | null | undefined, paymentcurrency: string | null | undefined, date: string | null | undefined, signature: string | null | undefined, istest: string | null | undefined, cashback: string | null | undefined, token: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Payment/Result?";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (invoiceid === null)
            throw new Error("The parameter 'invoiceid' cannot be null.");
        else if (invoiceid !== undefined)
            url_ += "invoiceid=" + encodeURIComponent("" + invoiceid) + "&";
        if (paymentsum !== undefined && paymentsum !== null)
            url_ += "paymentsum=" + encodeURIComponent("" + paymentsum) + "&";
        if (paymentcurrency !== undefined && paymentcurrency !== null)
            url_ += "paymentcurrency=" + encodeURIComponent("" + paymentcurrency) + "&";
        if (date !== undefined && date !== null)
            url_ += "date=" + encodeURIComponent("" + date) + "&";
        if (signature !== undefined && signature !== null)
            url_ += "signature=" + encodeURIComponent("" + signature) + "&";
        if (istest !== undefined && istest !== null)
            url_ += "istest=" + encodeURIComponent("" + istest) + "&";
        if (cashback !== undefined && cashback !== null)
            url_ += "cashback=" + encodeURIComponent("" + cashback) + "&";
        if (token !== undefined && token !== null)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPayment_Result(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPayment_Result(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPayment_Result(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    payment_Md5(str: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Payment?";
        if (str !== undefined && str !== null)
            url_ += "str=" + encodeURIComponent("" + str) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPayment_Md5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPayment_Md5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPayment_Md5(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Создание платежа
     * @param model ID заказа и тип оплаты
     * @return Модель с полями для отправки на сайт АПБ-WebPayment
     */
    payment_PayOrder(model: PayOrderRequest): Observable<ApbInvoice> {
        let url_ = this.baseUrl + "/api/Payment/PayOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPayment_PayOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPayment_PayOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApbInvoice>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApbInvoice>;
        }));
    }

    protected processPayment_PayOrder(response: HttpResponseBase): Observable<ApbInvoice> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApbInvoice;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Инфо пользователя
     */
    profile_GetProfileInfo(): Observable<UserProfileResponse> {
        let url_ = this.baseUrl + "/profiles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfile_GetProfileInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfile_GetProfileInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileResponse>;
        }));
    }

    protected processProfile_GetProfileInfo(response: HttpResponseBase): Observable<UserProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserProfileResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Список авто из гаража
     */
    profile_GetGarageCars(): Observable<GarageCarsResponse> {
        let url_ = this.baseUrl + "/GarageCars";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfile_GetGarageCars(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfile_GetGarageCars(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GarageCarsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GarageCarsResponse>;
        }));
    }

    protected processProfile_GetGarageCars(response: HttpResponseBase): Observable<GarageCarsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GarageCarsResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Добавление авто в гараж
     * @param request Автомобиль для добавления в гараж
     */
    profile_AddCarToGarage(request: AddToGarageCarsRequest): Observable<CarResponse> {
        let url_ = this.baseUrl + "/GarageCars";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfile_AddCarToGarage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfile_AddCarToGarage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CarResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CarResponse>;
        }));
    }

    protected processProfile_AddCarToGarage(response: HttpResponseBase): Observable<CarResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CarResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Удаление авто из гаража
     * @param userModificationVehicleId (optional)
     */
    profile_RemoveCarFromGarage(userModificationVehicleId: string | undefined): Observable<CarResponse> {
        let url_ = this.baseUrl + "/GarageCars?";
        if (userModificationVehicleId === null)
            throw new Error("The parameter 'userModificationVehicleId' cannot be null.");
        else if (userModificationVehicleId !== undefined)
            url_ += "userModificationVehicleId=" + encodeURIComponent("" + userModificationVehicleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfile_RemoveCarFromGarage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfile_RemoveCarFromGarage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CarResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CarResponse>;
        }));
    }

    protected processProfile_RemoveCarFromGarage(response: HttpResponseBase): Observable<CarResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CarResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Обновление записи автомобиля в гараже
     * @param request Автомобиль для добавления в гараж
     */
    profile_UpdateGarageCar(request: UpdateGarageCarRequest): Observable<CarResponse> {
        let url_ = this.baseUrl + "/GarageCars";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfile_UpdateGarageCar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfile_UpdateGarageCar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CarResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CarResponse>;
        }));
    }

    protected processProfile_UpdateGarageCar(response: HttpResponseBase): Observable<CarResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CarResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Добавление или обновление складов пользователя
     * @param binding Биндинг
     */
    profile_UpdateUserStore(binding: UserStore1CRequest[]): Observable<boolean> {
        let url_ = this.baseUrl + "/users/stores";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfile_UpdateUserStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfile_UpdateUserStore(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processProfile_UpdateUserStore(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Чаты пользователя получить
     * @param binding Биндинг
     */
    profile_UserChats(binding: ChatRequest): Observable<ChatHelperResponse> {
        let url_ = this.baseUrl + "/users/chats";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfile_UserChats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfile_UserChats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatHelperResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatHelperResponse>;
        }));
    }

    protected processProfile_UserChats(response: HttpResponseBase): Observable<ChatHelperResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ChatHelperResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Чаты пользователя добавить
     * @param binding Биндинг
     */
    profile_UserChatsMessage(binding: ChatMessageRequest): Observable<ChatResponse> {
        let url_ = this.baseUrl + "/users/chats/messages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfile_UserChatsMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfile_UserChatsMessage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatResponse>;
        }));
    }

    protected processProfile_UserChatsMessage(response: HttpResponseBase): Observable<ChatResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ChatResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Чаты пользователя обновить инфу
     * @param ids Биндинг
     */
    profile_UserChatsInfo(ids: string[]): Observable<ChatHelperResponse> {
        let url_ = this.baseUrl + "/users/chats/info";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfile_UserChatsInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfile_UserChatsInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatHelperResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatHelperResponse>;
        }));
    }

    protected processProfile_UserChatsInfo(response: HttpResponseBase): Observable<ChatHelperResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ChatHelperResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Чаты пользователя обновить читаемость
     */
    profile_NewMessagesCount(): Observable<number> {
        let url_ = this.baseUrl + "/users/chats/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfile_NewMessagesCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfile_NewMessagesCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processProfile_NewMessagesCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Чаты пользователя обновить читаемость
     */
    profile_UpdateRead(): Observable<boolean> {
        let url_ = this.baseUrl + "/users/chats/read";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfile_UpdateRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfile_UpdateRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processProfile_UpdateRead(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Пустые идентификаторы 1С
     */
    profile_EmptyIds1CAll(): Observable<UserResponse[]> {
        let url_ = this.baseUrl + "/users/empty";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfile_EmptyIds1CAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfile_EmptyIds1CAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserResponse[]>;
        }));
    }

    protected processProfile_EmptyIds1CAll(response: HttpResponseBase): Observable<UserResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Пустые идентификаторы 1С присвоить
     * @param binding Биндинг
     */
    profile_EmptyIds1C(binding: UserEmptyRequest[]): Observable<boolean> {
        let url_ = this.baseUrl + "/users/empty";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfile_EmptyIds1C(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfile_EmptyIds1C(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processProfile_EmptyIds1C(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Пользователь по id1c
     * @param id1C Идентификатор 1С
     */
    profile_UserById1C(id1C: string): Observable<boolean> {
        let url_ = this.baseUrl + "/users/{id1C}";
        if (id1C === undefined || id1C === null)
            throw new Error("The parameter 'id1C' must be defined.");
        url_ = url_.replace("{id1C}", encodeURIComponent("" + id1C));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfile_UserById1C(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfile_UserById1C(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processProfile_UserById1C(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Пополнение баланса
     * @param model Сумма пополнения
     * @return Модель с полями для отправки на сайт АПБ-WebPayment
     */
    profile_Replenishment(model: PayReplenishmentRequest): Observable<ApbInvoice> {
        let url_ = this.baseUrl + "/api/Profile/Replenishment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfile_Replenishment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfile_Replenishment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApbInvoice>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApbInvoice>;
        }));
    }

    protected processProfile_Replenishment(response: HttpResponseBase): Observable<ApbInvoice> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApbInvoice;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * История пополнения баланса
     */
    profile_UserBalance(): Observable<UserBalanceResponse> {
        let url_ = this.baseUrl + "/api/Profile/UserBalance";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfile_UserBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfile_UserBalance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserBalanceResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserBalanceResponse>;
        }));
    }

    protected processProfile_UserBalance(response: HttpResponseBase): Observable<UserBalanceResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserBalanceResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Автоподстановка названия товара
     * @param query (optional) Искомая строка
     * @param page (optional) Страница
     * @param pageSize (optional) Количество результатов
     */
    search_SuggestProducts(query: string | null | undefined, page: number | undefined, pageSize: number | undefined): Observable<SuggestResponse> {
        let url_ = this.baseUrl + "/api/Search/Suggest?";
        if (query !== undefined && query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch_SuggestProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch_SuggestProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SuggestResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SuggestResponse>;
        }));
    }

    protected processSearch_SuggestProducts(response: HttpResponseBase): Observable<SuggestResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SuggestResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Exception;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Ускоренный поиск товара из поисковой строки
     * @param query Искомая строка
     */
    search_SearchTaskFast(query: SearchRequest): Observable<FullSearchResponse> {
        let url_ = this.baseUrl + "/api/Search/SearchFast";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch_SearchTaskFast(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch_SearchTaskFast(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FullSearchResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FullSearchResponse>;
        }));
    }

    protected processSearch_SearchTaskFast(response: HttpResponseBase): Observable<FullSearchResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as FullSearchResponse;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Поиск товара из поисковой строки
     * @param query Искомая строка
     */
    search_SearchTask(query: SearchRequest): Observable<FullSearchResponse> {
        let url_ = this.baseUrl + "/api/Search/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch_SearchTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch_SearchTask(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FullSearchResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FullSearchResponse>;
        }));
    }

    protected processSearch_SearchTask(response: HttpResponseBase): Observable<FullSearchResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as FullSearchResponse;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Exception;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить первые 10 записей
     */
    test_GetAllData(): Observable<void> {
        let url_ = this.baseUrl + "/test";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTest_GetAllData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTest_GetAllData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTest_GetAllData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить запись по идентификатору
     * @param id Идентификатор записи
     */
    test_GetById(id: string): Observable<void> {
        let url_ = this.baseUrl + "/test/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTest_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTest_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTest_GetById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Добавление записи
     * @param access_token (optional)
     * @param user_name (optional)
     */
    test_Add(access_token: string | null | undefined, user_name: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/testadd?";
        if (access_token !== undefined && access_token !== null)
            url_ += "access_token=" + encodeURIComponent("" + access_token) + "&";
        if (user_name !== undefined && user_name !== null)
            url_ += "user_name=" + encodeURIComponent("" + user_name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTest_Add(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTest_Add(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTest_Add(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Обновление записи
     * @param id Идентификатор записи
     * @param binding Биндинг записи
     */
    test_Update(id: string, binding: TestBinding): Observable<void> {
        let url_ = this.baseUrl + "/testupdate/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTest_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTest_Update(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTest_Update(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Удаление записи
     * @param id Идентификатор записи
     */
    test_Remove(id: string): Observable<void> {
        let url_ = this.baseUrl + "/testdelete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTest_Remove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTest_Remove(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTest_Remove(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Тест нотифера
     */
    test_TestNotify(msg: NotifyBroadcastMessageBinding): Observable<void> {
        let url_ = this.baseUrl + "/testnotify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(msg);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTest_TestNotify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTest_TestNotify(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTest_TestNotify(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Новости и акции на главной странице
     */
    article_GetHomeArticles(): Observable<ArticleResponse[]> {
        let url_ = this.baseUrl + "/api/Article/home";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processArticle_GetHomeArticles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processArticle_GetHomeArticles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ArticleResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ArticleResponse[]>;
        }));
    }

    protected processArticle_GetHomeArticles(response: HttpResponseBase): Observable<ArticleResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ArticleResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Вывести новости и акции
     */
    article_Articles(binding: BlogRequest): Observable<ArticleResponse[]> {
        let url_ = this.baseUrl + "/api/Article";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processArticle_Articles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processArticle_Articles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ArticleResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ArticleResponse[]>;
        }));
    }

    protected processArticle_Articles(response: HttpResponseBase): Observable<ArticleResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ArticleResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Показать одну
     */
    article_Article(stringKey: string): Observable<ArticleResponse> {
        let url_ = this.baseUrl + "/api/Article/{stringKey}";
        if (stringKey === undefined || stringKey === null)
            throw new Error("The parameter 'stringKey' must be defined.");
        url_ = url_.replace("{stringKey}", encodeURIComponent("" + stringKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processArticle_Article(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processArticle_Article(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ArticleResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ArticleResponse>;
        }));
    }

    protected processArticle_Article(response: HttpResponseBase): Observable<ArticleResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ArticleResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Создание или обновление корзины
     * @param binding Коллекция элементов корзины
     */
    basket_AddOrUpdateBasket(binding: BasketRequest[]): Observable<BasketRequest[]> {
        let url_ = this.baseUrl + "/api/Basket/baskets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBasket_AddOrUpdateBasket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBasket_AddOrUpdateBasket(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BasketRequest[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BasketRequest[]>;
        }));
    }

    protected processBasket_AddOrUpdateBasket(response: HttpResponseBase): Observable<BasketRequest[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BasketRequest[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Информация о корзине пользователя
     */
    basket_BasketInfo(binding: BasketRequest[]): Observable<BasketCityResponse[]> {
        let url_ = this.baseUrl + "/api/Basket/info";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBasket_BasketInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBasket_BasketInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BasketCityResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BasketCityResponse[]>;
        }));
    }

    protected processBasket_BasketInfo(response: HttpResponseBase): Observable<BasketCityResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BasketCityResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Количество товаров в корзине
     */
    basket_BasketCount(): Observable<BasketCountResponse> {
        let url_ = this.baseUrl + "/api/Basket/count";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBasket_BasketCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBasket_BasketCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BasketCountResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BasketCountResponse>;
        }));
    }

    protected processBasket_BasketCount(response: HttpResponseBase): Observable<BasketCountResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BasketCountResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Изменить количество товаров в элементе корзины
     * @param binding Элемент корзины
     */
    basket_ChangeCountItem(binding: BasketRequest): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Basket/count";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBasket_ChangeCountItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBasket_ChangeCountItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processBasket_ChangeCountItem(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Количество товаров в корзине
     */
    basket_BasketCountStorage(binding: BasketRequest[]): Observable<BasketCountResponse> {
        let url_ = this.baseUrl + "/api/Basket/storage/count";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBasket_BasketCountStorage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBasket_BasketCountStorage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BasketCountResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BasketCountResponse>;
        }));
    }

    protected processBasket_BasketCountStorage(response: HttpResponseBase): Observable<BasketCountResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BasketCountResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Удалить товар из корзины
     * @param binding Элемент корзины
     */
    basket_RemoveItem(binding: BasketRequest): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Basket/items";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBasket_RemoveItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBasket_RemoveItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processBasket_RemoveItem(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Проверить товары на наличие
     * @param binding Элемент корзины
     */
    basket_CheckBasketItemStorage(binding: BasketRequest[]): Observable<BasketRequest[]> {
        let url_ = this.baseUrl + "/api/Basket/count/check";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBasket_CheckBasketItemStorage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBasket_CheckBasketItemStorage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BasketRequest[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BasketRequest[]>;
        }));
    }

    protected processBasket_CheckBasketItemStorage(response: HttpResponseBase): Observable<BasketRequest[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BasketRequest[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получение списка брендов
     */
    brand_GetAll(): Observable<BrandResponse[]> {
        let url_ = this.baseUrl + "/api/Brand/brands";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBrand_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBrand_GetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BrandResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BrandResponse[]>;
        }));
    }

    protected processBrand_GetAll(response: HttpResponseBase): Observable<BrandResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BrandResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Добавление или обновление бренда (1c)
     * @param binding Биндинг бренда
     */
    brand_AddOrUpdate(binding: BrandRequest): Observable<BrandResponse> {
        let url_ = this.baseUrl + "/brands";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBrand_AddOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBrand_AddOrUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BrandResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BrandResponse>;
        }));
    }

    protected processBrand_AddOrUpdate(response: HttpResponseBase): Observable<BrandResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BrandResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Добавление или обновление брендов (1c)
     * @param binding Биндинг бренда
     */
    brand_AddOrUpdateMany(binding: BrandRequest[]): Observable<boolean> {
        let url_ = this.baseUrl + "/brands/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBrand_AddOrUpdateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBrand_AddOrUpdateMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processBrand_AddOrUpdateMany(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получение всех категорий
     */
    category_GetAll(): Observable<CategoryResponse[]> {
        let url_ = this.baseUrl + "/api/Category";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategory_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategory_GetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryResponse[]>;
        }));
    }

    protected processCategory_GetAll(response: HttpResponseBase): Observable<CategoryResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CategoryResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получение всех категорий
     */
    category_GetAllWithoutChild(): Observable<CategoryResponse[]> {
        let url_ = this.baseUrl + "/api/Category/getAllWithoutChild";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategory_GetAllWithoutChild(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategory_GetAllWithoutChild(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryResponse[]>;
        }));
    }

    protected processCategory_GetAllWithoutChild(response: HttpResponseBase): Observable<CategoryResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CategoryResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получение всех подкатегорий
     * @param id (optional)
     */
    category_GetChildsByParentId(id: string | undefined): Observable<CategoryResponse[]> {
        let url_ = this.baseUrl + "/api/Category/getChildsByParentId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategory_GetChildsByParentId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategory_GetChildsByParentId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryResponse[]>;
        }));
    }

    protected processCategory_GetChildsByParentId(response: HttpResponseBase): Observable<CategoryResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CategoryResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получение всех категорий
     */
    category_GetSale(isAll: boolean): Observable<CategoryResponse> {
        let url_ = this.baseUrl + "/api/Category/sale/{isAll}";
        if (isAll === undefined || isAll === null)
            throw new Error("The parameter 'isAll' must be defined.");
        url_ = url_.replace("{isAll}", encodeURIComponent("" + isAll));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategory_GetSale(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategory_GetSale(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryResponse>;
        }));
    }

    protected processCategory_GetSale(response: HttpResponseBase): Observable<CategoryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CategoryResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получение всех опций применяемости
     */
    category_GetApplyOptions(): Observable<OptionResponse[]> {
        let url_ = this.baseUrl + "/api/Category/options/apply";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategory_GetApplyOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategory_GetApplyOptions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OptionResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OptionResponse[]>;
        }));
    }

    protected processCategory_GetApplyOptions(response: HttpResponseBase): Observable<OptionResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OptionResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получение всех опций применяемости
     */
    category_GetApplyOptionsFilter(binding: SaleProductRequest): Observable<CategoryResponse> {
        let url_ = this.baseUrl + "/api/Category/options/apply";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategory_GetApplyOptionsFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategory_GetApplyOptionsFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryResponse>;
        }));
    }

    protected processCategory_GetApplyOptionsFilter(response: HttpResponseBase): Observable<CategoryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CategoryResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получение категории по идентификатору в БД
     * @param id Идентификатор категории
     */
    category_GetById(id: string): Observable<CategoryResponse> {
        let url_ = this.baseUrl + "/api/Category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategory_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategory_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryResponse>;
        }));
    }

    protected processCategory_GetById(response: HttpResponseBase): Observable<CategoryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CategoryResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить категорию по
     */
    category_GetByStringKey(stringKey: string): Observable<CategoryResponse> {
        let url_ = this.baseUrl + "/api/Category/categories/{stringKey}";
        if (stringKey === undefined || stringKey === null)
            throw new Error("The parameter 'stringKey' must be defined.");
        url_ = url_.replace("{stringKey}", encodeURIComponent("" + stringKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategory_GetByStringKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategory_GetByStringKey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryResponse>;
        }));
    }

    protected processCategory_GetByStringKey(response: HttpResponseBase): Observable<CategoryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CategoryResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Добавление или обновление категории
     * @param binding Биндинг категории
     */
    category_AddOrUpdate(binding: CategoryRequest): Observable<CategoryResponse> {
        let url_ = this.baseUrl + "/category";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategory_AddOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategory_AddOrUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryResponse>;
        }));
    }

    protected processCategory_AddOrUpdate(response: HttpResponseBase): Observable<CategoryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CategoryResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Добавление или обновление категорий
     * @param binding Биндинг категории
     */
    category_AddOrUpdateMany(binding: CategoryRequest[]): Observable<boolean> {
        let url_ = this.baseUrl + "/categories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategory_AddOrUpdateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategory_AddOrUpdateMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCategory_AddOrUpdateMany(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Добавление и обновление города (1с)
     * @param binding Биндинг города
     */
    city_Add(binding: CityRequest): Observable<CityResponse> {
        let url_ = this.baseUrl + "/cities";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCity_Add(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCity_Add(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityResponse>;
        }));
    }

    protected processCity_Add(response: HttpResponseBase): Observable<CityResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CityResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Создание ОС
     * @param binding Биндинг ОС
     */
    contactUs_Add(binding: ContactUsRequest): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ContactUs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContactUs_Add(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContactUs_Add(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processContactUs_Add(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить ОС по типу 0 - Новый 1- В процессе 2- Завершен 3 - Отклонен 4 - Все
     * @param binding Биндинг
     */
    contactUs_GetByStatus(binding: ContactUsStateRequest): Observable<AdminContactUsResponse[]> {
        let url_ = this.baseUrl + "/api/ContactUs/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContactUs_GetByStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContactUs_GetByStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminContactUsResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminContactUsResponse[]>;
        }));
    }

    protected processContactUs_GetByStatus(response: HttpResponseBase): Observable<AdminContactUsResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminContactUsResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Изменить ОС
     * @param binding Биндинг
     */
    contactUs_AddOrUpdate(binding: ContactUsUpdateRequest[]): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ContactUs/contacts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContactUs_AddOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContactUs_AddOrUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processContactUs_AddOrUpdate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Добавление страны (1с)
     * @param binding Биндинг страны
     */
    country_Add(binding: CountryRequest): Observable<CountryResponse> {
        let url_ = this.baseUrl + "/countries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCountry_Add(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCountry_Add(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryResponse>;
        }));
    }

    protected processCountry_Add(response: HttpResponseBase): Observable<CountryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CountryResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получение типов доставки
     */
    delivery_GetDelivery(): Observable<DeliveryResponse[]> {
        let url_ = this.baseUrl + "/api/Delivery/types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelivery_GetDelivery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelivery_GetDelivery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeliveryResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeliveryResponse[]>;
        }));
    }

    protected processDelivery_GetDelivery(response: HttpResponseBase): Observable<DeliveryResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeliveryResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить группы для скачивания
     */
    downloadInfo_All(): Observable<DownloadInfoResponse[]> {
        let url_ = this.baseUrl + "/api/DownloadInfo/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadInfo_All(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadInfo_All(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DownloadInfoResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DownloadInfoResponse[]>;
        }));
    }

    protected processDownloadInfo_All(response: HttpResponseBase): Observable<DownloadInfoResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DownloadInfoResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Добавление и обновление групп информации
     * @param binding Биндинг
     */
    downloadInfo_Add(binding: DownloadInfoRequest): Observable<DownloadInfoResponse> {
        let url_ = this.baseUrl + "/api/DownloadInfo/info";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadInfo_Add(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadInfo_Add(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DownloadInfoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DownloadInfoResponse>;
        }));
    }

    protected processDownloadInfo_Add(response: HttpResponseBase): Observable<DownloadInfoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DownloadInfoResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить группы для скачивания
     * @param stringKey StringKey
     */
    downloadInfo_AllItems(stringKey: string): Observable<DownloadInfoResponse> {
        let url_ = this.baseUrl + "/api/DownloadInfo/info/{stringKey}";
        if (stringKey === undefined || stringKey === null)
            throw new Error("The parameter 'stringKey' must be defined.");
        url_ = url_.replace("{stringKey}", encodeURIComponent("" + stringKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadInfo_AllItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadInfo_AllItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DownloadInfoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DownloadInfoResponse>;
        }));
    }

    protected processDownloadInfo_AllItems(response: HttpResponseBase): Observable<DownloadInfoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DownloadInfoResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Добавление и обновление информации
     * @param binding Биндинг
     */
    downloadInfo_AddItem(binding: DownloadInfoItemRequest): Observable<DownloadInfoResponse> {
        let url_ = this.baseUrl + "/api/DownloadInfo/info/items";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadInfo_AddItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadInfo_AddItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DownloadInfoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DownloadInfoResponse>;
        }));
    }

    protected processDownloadInfo_AddItem(response: HttpResponseBase): Observable<DownloadInfoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DownloadInfoResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Все сектора
     */
    logistic_GetSectors(): Observable<SectorResponse[]> {
        let url_ = this.baseUrl + "/api/Logistic/sectors";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogistic_GetSectors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogistic_GetSectors(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SectorResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SectorResponse[]>;
        }));
    }

    protected processLogistic_GetSectors(response: HttpResponseBase): Observable<SectorResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SectorResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Все маршруты
     */
    logistic_GetRoutes(): Observable<RouteResponse[]> {
        let url_ = this.baseUrl + "/api/Logistic/routes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogistic_GetRoutes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogistic_GetRoutes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RouteResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RouteResponse[]>;
        }));
    }

    protected processLogistic_GetRoutes(response: HttpResponseBase): Observable<RouteResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RouteResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Сектор по идентификатору
     * @param id Идентификатор
     */
    logistic_GetSectorById(id: number): Observable<SectorResponse> {
        let url_ = this.baseUrl + "/api/Logistic/sectors/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogistic_GetSectorById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogistic_GetSectorById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SectorResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SectorResponse>;
        }));
    }

    protected processLogistic_GetSectorById(response: HttpResponseBase): Observable<SectorResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SectorResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Сектор по идентификатору 1c
     * @param id1C Идентификатор 1С
     */
    logistic_GetSectorById1C(id1C: string): Observable<SectorResponse> {
        let url_ = this.baseUrl + "/api/Logistic/sectors/{id1C}";
        if (id1C === undefined || id1C === null)
            throw new Error("The parameter 'id1C' must be defined.");
        url_ = url_.replace("{id1C}", encodeURIComponent("" + id1C));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogistic_GetSectorById1C(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogistic_GetSectorById1C(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SectorResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SectorResponse>;
        }));
    }

    protected processLogistic_GetSectorById1C(response: HttpResponseBase): Observable<SectorResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SectorResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Маршрут по идентификатору
     * @param id Идентификатор
     */
    logistic_GetRouteById(id: number): Observable<RouteResponse> {
        let url_ = this.baseUrl + "/api/Logistic/routes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogistic_GetRouteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogistic_GetRouteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RouteResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RouteResponse>;
        }));
    }

    protected processLogistic_GetRouteById(response: HttpResponseBase): Observable<RouteResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RouteResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Маршрут по идентификатору 1c
     * @param id1C Идентификатор 1С
     */
    logistic_GetRouteById1C(id1C: string): Observable<RouteResponse> {
        let url_ = this.baseUrl + "/api/Logistic/routes/{id1C}";
        if (id1C === undefined || id1C === null)
            throw new Error("The parameter 'id1C' must be defined.");
        url_ = url_.replace("{id1C}", encodeURIComponent("" + id1C));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogistic_GetRouteById1C(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogistic_GetRouteById1C(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RouteResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RouteResponse>;
        }));
    }

    protected processLogistic_GetRouteById1C(response: HttpResponseBase): Observable<RouteResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RouteResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Добавление или обновление сектора (1c)
     * @param binding Биндинг сектора
     */
    logistic_AddOrUpdateSector(binding: SectorRequest): Observable<SectorRequest> {
        let url_ = this.baseUrl + "/sectors";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogistic_AddOrUpdateSector(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogistic_AddOrUpdateSector(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SectorRequest>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SectorRequest>;
        }));
    }

    protected processLogistic_AddOrUpdateSector(response: HttpResponseBase): Observable<SectorRequest> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SectorRequest;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Добавление или обновление маршрута (1c)
     * @param binding Биндинг сектора
     */
    logistic_AddOrUpdateRoute(binding: RouteRequest): Observable<RouteRequest> {
        let url_ = this.baseUrl + "/routes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogistic_AddOrUpdateRoute(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogistic_AddOrUpdateRoute(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RouteRequest>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RouteRequest>;
        }));
    }

    protected processLogistic_AddOrUpdateRoute(response: HttpResponseBase): Observable<RouteRequest> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RouteRequest;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Перезапись секторов пользователей (1c)
     * @param binding Биндинг секторов пользователей
     */
    logistic_UpdateUserSectors(binding: UserSectorRequest[]): Observable<boolean> {
        let url_ = this.baseUrl + "/sectors/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogistic_UpdateUserSectors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogistic_UpdateUserSectors(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processLogistic_UpdateUserSectors(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Перезапись секторов маршрутов (1c)
     * @param binding Биндинг секторов маршрутов
     */
    logistic_UpdateRouteSectors(binding: RouteSectorRequest[]): Observable<boolean> {
        let url_ = this.baseUrl + "/sectors/routes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogistic_UpdateRouteSectors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogistic_UpdateRouteSectors(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processLogistic_UpdateRouteSectors(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Логистика пользователя
     */
    logistic_UserSector(): Observable<RouteResponse[]> {
        let url_ = this.baseUrl + "/api/Logistic/sectors/users";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogistic_UserSector(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogistic_UserSector(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RouteResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RouteResponse[]>;
        }));
    }

    protected processLogistic_UserSector(response: HttpResponseBase): Observable<RouteResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RouteResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получение меню главной
     */
    menu_GetMainSection(): Observable<MenuSectionResponse> {
        let url_ = this.baseUrl + "/api/Menu/home";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMenu_GetMainSection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMenu_GetMainSection(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MenuSectionResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MenuSectionResponse>;
        }));
    }

    protected processMenu_GetMainSection(response: HttpResponseBase): Observable<MenuSectionResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MenuSectionResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Добавление или обновление опции (1c)
     * @param binding Биндинг опции
     */
    option_AddOption(binding: OptionRequest): Observable<OptionResponse> {
        let url_ = this.baseUrl + "/options";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOption_AddOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOption_AddOption(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OptionResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OptionResponse>;
        }));
    }

    protected processOption_AddOption(response: HttpResponseBase): Observable<OptionResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OptionResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Добавление или обновление опций (1c)
     * @param binding Биндинг опции
     */
    option_AddOptions(binding: OptionRequest[]): Observable<boolean> {
        let url_ = this.baseUrl + "/options/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOption_AddOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOption_AddOptions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processOption_AddOptions(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Добавление или обновление значений опции (1c)
     * @param binding Биндинг опции
     */
    option_AddOptionValueMany(binding: OptionValueRequest): Observable<OptionResponse> {
        let url_ = this.baseUrl + "/optionvalue";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOption_AddOptionValueMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOption_AddOptionValueMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OptionResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OptionResponse>;
        }));
    }

    protected processOption_AddOptionValueMany(response: HttpResponseBase): Observable<OptionResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OptionResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Добавление или обновление значений опций (1c)
     * @param binding Биндинг опциий
     */
    option_AddOptionValueMany2(binding: OptionValueRequest[]): Observable<boolean> {
        let url_ = this.baseUrl + "/optionvalue/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOption_AddOptionValueMany2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOption_AddOptionValueMany2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processOption_AddOptionValueMany2(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Список страниц
     */
    page_Pages(): Observable<PageResponse[]> {
        let url_ = this.baseUrl + "/api/Page";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPage_Pages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPage_Pages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PageResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PageResponse[]>;
        }));
    }

    protected processPage_Pages(response: HttpResponseBase): Observable<PageResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PageResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Страница по ссылке
     * @param stringKey Ссылка
     */
    page_PageById(stringKey: string): Observable<PageResponse> {
        let url_ = this.baseUrl + "/api/Page/{stringKey}";
        if (stringKey === undefined || stringKey === null)
            throw new Error("The parameter 'stringKey' must be defined.");
        url_ = url_.replace("{stringKey}", encodeURIComponent("" + stringKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPage_PageById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPage_PageById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PageResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PageResponse>;
        }));
    }

    protected processPage_PageById(response: HttpResponseBase): Observable<PageResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PageResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Все поставщики
     */
    partner_Partners(): Observable<PartnerResponse[]> {
        let url_ = this.baseUrl + "/api/Partner";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPartner_Partners(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPartner_Partners(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartnerResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartnerResponse[]>;
        }));
    }

    protected processPartner_Partners(response: HttpResponseBase): Observable<PartnerResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PartnerResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Поставщик по идентификатору
     * @param id Поставщик по идентификатору
     */
    partner_PartnerById(id: number): Observable<PartnerResponse> {
        let url_ = this.baseUrl + "/api/Partner/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPartner_PartnerById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPartner_PartnerById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartnerResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartnerResponse>;
        }));
    }

    protected processPartner_PartnerById(response: HttpResponseBase): Observable<PartnerResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PartnerResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Типы оплаты
     */
    payment_GetPaymentTypes(): Observable<PaymentTypeResponse[]> {
        let url_ = this.baseUrl + "/payments/types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPayment_GetPaymentTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPayment_GetPaymentTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentTypeResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentTypeResponse[]>;
        }));
    }

    protected processPayment_GetPaymentTypes(response: HttpResponseBase): Observable<PaymentTypeResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaymentTypeResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Добавление или обновления уровня цен (1c)
     * @param binding Биндинг уровня цены
     */
    priceLevel_AddOrUpdate(binding: PriceLevelRequest): Observable<PriceLevelResponse> {
        let url_ = this.baseUrl + "/prices/levels";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPriceLevel_AddOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPriceLevel_AddOrUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PriceLevelResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PriceLevelResponse>;
        }));
    }

    protected processPriceLevel_AddOrUpdate(response: HttpResponseBase): Observable<PriceLevelResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PriceLevelResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Обновление брендов для уровня цен (1c)
     * @param binding Биндинг уровня цены
     */
    priceLevel_Update(binding: PriceLevelBrandRequest[]): Observable<boolean> {
        let url_ = this.baseUrl + "/prices/levels/brands";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPriceLevel_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPriceLevel_Update(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processPriceLevel_Update(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Товар то артикулу stringKey
     * @param keyString (optional) Артикул или stringkey
     * @param code (optional)
     * @param tecDocBrandId (optional)
     */
    product_GetProduct(keyString: string | null | undefined, code: string | null | undefined, tecDocBrandId: number | undefined): Observable<ProductPageResponse> {
        let url_ = this.baseUrl + "/products?";
        if (keyString !== undefined && keyString !== null)
            url_ += "keyString=" + encodeURIComponent("" + keyString) + "&";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (tecDocBrandId === null)
            throw new Error("The parameter 'tecDocBrandId' cannot be null.");
        else if (tecDocBrandId !== undefined)
            url_ += "tecDocBrandId=" + encodeURIComponent("" + tecDocBrandId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProduct_GetProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProduct_GetProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductPageResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductPageResponse>;
        }));
    }

    protected processProduct_GetProduct(response: HttpResponseBase): Observable<ProductPageResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProductPageResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Добавление или обновление товаров
     * @param binding Биндинг
     */
    product_AddOrUpdateProducts(binding: ProductRequest[]): Observable<boolean> {
        let url_ = this.baseUrl + "/products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProduct_AddOrUpdateProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProduct_AddOrUpdateProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processProduct_AddOrUpdateProducts(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Аналоги для авто
     */
    product_GetProductAnalogsResponseResult(binding: ProductAnalogHelper): Observable<ProductAnalogHelper> {
        let url_ = this.baseUrl + "/products/apply";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProduct_GetProductAnalogsResponseResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProduct_GetProductAnalogsResponseResult(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductAnalogHelper>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductAnalogHelper>;
        }));
    }

    protected processProduct_GetProductAnalogsResponseResult(response: HttpResponseBase): Observable<ProductAnalogHelper> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProductAnalogHelper;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Применяемость для товара - Марки Авто
     * @param articul (optional)
     * @param brandId (optional)
     */
    product_GetProductApplyCars(articul: string | null | undefined, brandId: number | undefined): Observable<CarApplicabilityMarksResponse[]> {
        let url_ = this.baseUrl + "/products/apply?";
        if (articul !== undefined && articul !== null)
            url_ += "Articul=" + encodeURIComponent("" + articul) + "&";
        if (brandId === null)
            throw new Error("The parameter 'brandId' cannot be null.");
        else if (brandId !== undefined)
            url_ += "BrandId=" + encodeURIComponent("" + brandId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProduct_GetProductApplyCars(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProduct_GetProductApplyCars(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CarApplicabilityMarksResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CarApplicabilityMarksResponse[]>;
        }));
    }

    protected processProduct_GetProductApplyCars(response: HttpResponseBase): Observable<CarApplicabilityMarksResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CarApplicabilityMarksResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Применяемость для товара -Модели авто
     * @param carMarkId (optional)
     */
    product_GetProductApply(carMarkId: string | undefined): Observable<CarTreeResponse[]> {
        let url_ = this.baseUrl + "/products/applyMarks?";
        if (carMarkId === null)
            throw new Error("The parameter 'carMarkId' cannot be null.");
        else if (carMarkId !== undefined)
            url_ += "carMarkId=" + encodeURIComponent("" + carMarkId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProduct_GetProductApply(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProduct_GetProductApply(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CarTreeResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CarTreeResponse[]>;
        }));
    }

    protected processProduct_GetProductApply(response: HttpResponseBase): Observable<CarTreeResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CarTreeResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Добавление или обновление товаров 2
     * @param binding Биндинг
     */
    product_AddOrUpdateProducts2(binding: ProductRequest[]): Observable<boolean> {
        let url_ = this.baseUrl + "/products2";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProduct_AddOrUpdateProducts2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProduct_AddOrUpdateProducts2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processProduct_AddOrUpdateProducts2(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Добавление или обновление товаров 3 ЧЕРЕЗ SQL
     * @param binding Биндинг
     */
    product_AddOrUpdateProducts3(binding: ProductSQLSource[]): Observable<boolean> {
        let url_ = this.baseUrl + "/products3";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProduct_AddOrUpdateProducts3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProduct_AddOrUpdateProducts3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processProduct_AddOrUpdateProducts3(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Товары для категории
     * @param binding Биндинг категории
     */
    product_GetCategoryProducts(binding: CategoryProductRequest): Observable<ProductPaginatorResponse> {
        let url_ = this.baseUrl + "/categories/products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProduct_GetCategoryProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProduct_GetCategoryProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductPaginatorResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductPaginatorResponse>;
        }));
    }

    protected processProduct_GetCategoryProducts(response: HttpResponseBase): Observable<ProductPaginatorResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProductPaginatorResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Товара для категории sale
     * @param binding Биндинг категории
     */
    product_SaleCategoryProducts(binding: CategoryProductRequest): Observable<ProductSalePaginatorResponse> {
        let url_ = this.baseUrl + "/categories/sale/products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProduct_SaleCategoryProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProduct_SaleCategoryProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductSalePaginatorResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductSalePaginatorResponse>;
        }));
    }

    protected processProduct_SaleCategoryProducts(response: HttpResponseBase): Observable<ProductSalePaginatorResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProductSalePaginatorResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Товары для главной
     */
    product_GetHomeProducts(): Observable<PageProductHomeSectionsResponse> {
        let url_ = this.baseUrl + "/products/home";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProduct_GetHomeProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProduct_GetHomeProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PageProductHomeSectionsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PageProductHomeSectionsResponse>;
        }));
    }

    protected processProduct_GetHomeProducts(response: HttpResponseBase): Observable<PageProductHomeSectionsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PageProductHomeSectionsResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Товары акционные TecDoc
     * @param binding Список моделей для товаров
     */
    product_AddOrUpdateProductCarModel(binding: ProductCarModelRequest[]): Observable<boolean> {
        let url_ = this.baseUrl + "/products/tecdoc/sale";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProduct_AddOrUpdateProductCarModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProduct_AddOrUpdateProductCarModel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processProduct_AddOrUpdateProductCarModel(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить иконки соц.сетей
     */
    setting_GetSocialNetworks(): Observable<SocialNetworkResponse[]> {
        let url_ = this.baseUrl + "/api/Setting/socials";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetting_GetSocialNetworks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetting_GetSocialNetworks(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SocialNetworkResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SocialNetworkResponse[]>;
        }));
    }

    protected processSetting_GetSocialNetworks(response: HttpResponseBase): Observable<SocialNetworkResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SocialNetworkResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить инфо футера
     */
    setting_GetFooterInfo(): Observable<FooterResponse> {
        let url_ = this.baseUrl + "/api/Setting/footer/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetting_GetFooterInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetting_GetFooterInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FooterResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FooterResponse>;
        }));
    }

    protected processSetting_GetFooterInfo(response: HttpResponseBase): Observable<FooterResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as FooterResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить настройки
     */
    setting_GetCommonSettings(): Observable<SettingsResponse> {
        let url_ = this.baseUrl + "/api/Setting/common";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetting_GetCommonSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetting_GetCommonSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SettingsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SettingsResponse>;
        }));
    }

    protected processSetting_GetCommonSettings(response: HttpResponseBase): Observable<SettingsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SettingsResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить настройки
     */
    setting_GetCommonBool(): Observable<SettingActiveResponse> {
        let url_ = this.baseUrl + "/api/Setting/common/bool";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetting_GetCommonBool(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetting_GetCommonBool(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SettingActiveResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SettingActiveResponse>;
        }));
    }

    protected processSetting_GetCommonBool(response: HttpResponseBase): Observable<SettingActiveResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SettingActiveResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получение слайдера главной
     */
    slider_GetMainSlider(): Observable<SliderResponse> {
        let url_ = this.baseUrl + "/api/Slider/home";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSlider_GetMainSlider(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSlider_GetMainSlider(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SliderResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SliderResponse>;
        }));
    }

    protected processSlider_GetMainSlider(response: HttpResponseBase): Observable<SliderResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SliderResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Запись на СТО
     * @param binding Биндинг
     */
    sto_Add(binding: StoRequest): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Sto";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSto_Add(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSto_Add(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSto_Add(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Авто пользователя
     * @param modificationId Идентификатор автомобиля пользователя
     */
    sto_UserCar(modificationId: string): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Sto/{modificationId}";
        if (modificationId === undefined || modificationId === null)
            throw new Error("The parameter 'modificationId' must be defined.");
        url_ = url_.replace("{modificationId}", encodeURIComponent("" + modificationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSto_UserCar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSto_UserCar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processSto_UserCar(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить СТО по типу 0 - Новый 1- Обработан 2- Выполнен 3 - Отменен менеджером 4 - Отменен клиентом
     * @param binding Биндинг
     */
    sto_GetByStatus(binding: StoFilterRequest): Observable<AdminStoResponse[]> {
        let url_ = this.baseUrl + "/api/Sto/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSto_GetByStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSto_GetByStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminStoResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminStoResponse[]>;
        }));
    }

    protected processSto_GetByStatus(response: HttpResponseBase): Observable<AdminStoResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminStoResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Изменить СТО
     * @param binding Биндинг
     */
    sto_AddOrUpdate(binding: StoSubUpdateRequest[]): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Sto/sto";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSto_AddOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSto_AddOrUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSto_AddOrUpdate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Изменить статус СТО
     * @param binding Биндинг
     */
    sto_UpdateStatus(binding: StoSubStatusUpdateRequest[]): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Sto/status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSto_UpdateStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSto_UpdateStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSto_UpdateStatus(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получение всех сервисов
     */
    store_GetAllService(): Observable<StoreServiceResponse[]> {
        let url_ = this.baseUrl + "/services";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStore_GetAllService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStore_GetAllService(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreServiceResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreServiceResponse[]>;
        }));
    }

    protected processStore_GetAllService(response: HttpResponseBase): Observable<StoreServiceResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreServiceResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Добавление или обновление склада (1c)
     */
    store_Add(binding: StoreRequest): Observable<StoreResponse> {
        let url_ = this.baseUrl + "/stores";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStore_Add(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStore_Add(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreResponse>;
        }));
    }

    protected processStore_Add(response: HttpResponseBase): Observable<StoreResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Список на футер
     */
    store_GetFooter(): Observable<StoreResponse[]> {
        let url_ = this.baseUrl + "/api/Store/footer";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStore_GetFooter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStore_GetFooter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreResponse[]>;
        }));
    }

    protected processStore_GetFooter(response: HttpResponseBase): Observable<StoreResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Список всех
     */
    store_GetAll(): Observable<StoreResponse[]> {
        let url_ = this.baseUrl + "/api/Store";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStore_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStore_GetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreResponse[]>;
        }));
    }

    protected processStore_GetAll(response: HttpResponseBase): Observable<StoreResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Добавление или обновление
     * @param binding Биндинг
     */
    unit_Add(binding: UnitRequest): Observable<UnitResponse> {
        let url_ = this.baseUrl + "/units";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnit_Add(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnit_Add(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitResponse>;
        }));
    }

    protected processUnit_Add(response: HttpResponseBase): Observable<UnitResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnitResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получение избранного
     */
    wishList_GetWishList(): Observable<WishListResponse> {
        let url_ = this.baseUrl + "/api/WishList/wishlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWishList_GetWishList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWishList_GetWishList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WishListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WishListResponse>;
        }));
    }

    protected processWishList_GetWishList(response: HttpResponseBase): Observable<WishListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as WishListResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Добавить в избранное
     * @param productIds Коллекция элементов
     */
    wishList_AddToWish(productIds: string[]): Observable<WishListResponse> {
        let url_ = this.baseUrl + "/api/WishList/wishlist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(productIds);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWishList_AddToWish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWishList_AddToWish(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WishListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WishListResponse>;
        }));
    }

    protected processWishList_AddToWish(response: HttpResponseBase): Observable<WishListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as WishListResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Удалить из избранного
     * @param itemIds Коллекция элементов
     */
    wishList_RemoveFromWish(itemIds: string[]): Observable<boolean> {
        let url_ = this.baseUrl + "/api/WishList/wishlist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(itemIds);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWishList_RemoveFromWish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWishList_RemoveFromWish(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processWishList_RemoveFromWish(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получение всех марок авто
     */
    car_GetMarksList(): Observable<CarMarksResponse[]> {
        let url_ = this.baseUrl + "/api/Car/Marks";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCar_GetMarksList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCar_GetMarksList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CarMarksResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CarMarksResponse[]>;
        }));
    }

    protected processCar_GetMarksList(response: HttpResponseBase): Observable<CarMarksResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CarMarksResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получение всех моделей авто
     */
    car_GetModelsList(): Observable<CarModelsResponse> {
        let url_ = this.baseUrl + "/api/Car/Models";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCar_GetModelsList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCar_GetModelsList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CarModelsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CarModelsResponse>;
        }));
    }

    protected processCar_GetModelsList(response: HttpResponseBase): Observable<CarModelsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CarModelsResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получение списка моделей по идентификатору марки авто
     * @param markaId Идентификатор марки авто
     */
    car_GetModelsByMarkaIdList(markaId: string): Observable<CarModelsResponse[]> {
        let url_ = this.baseUrl + "/api/Car/Models/{markaId}";
        if (markaId === undefined || markaId === null)
            throw new Error("The parameter 'markaId' must be defined.");
        url_ = url_.replace("{markaId}", encodeURIComponent("" + markaId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCar_GetModelsByMarkaIdList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCar_GetModelsByMarkaIdList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CarModelsResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CarModelsResponse[]>;
        }));
    }

    protected processCar_GetModelsByMarkaIdList(response: HttpResponseBase): Observable<CarModelsResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CarModelsResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получение списка модификаций по идентификатору модели авто
     * @param modelId Идентификатор модели авто
     */
    car_GetModificationsByModelId(modelId: string): Observable<CarModificationsResponse[]> {
        let url_ = this.baseUrl + "/api/Car/Modifications/{modelId}";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCar_GetModificationsByModelId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCar_GetModificationsByModelId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CarModificationsResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CarModificationsResponse[]>;
        }));
    }

    protected processCar_GetModificationsByModelId(response: HttpResponseBase): Observable<CarModificationsResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CarModificationsResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получение информации об автомобиле
     * @param modificationid (optional) TecDoc идентификатор модификации автомобиля
     */
    car_GetСarDetails(modificationid: number | undefined): Observable<CarDetailResponse> {
        let url_ = this.baseUrl + "/api/Car/Detail?";
        if (modificationid === null)
            throw new Error("The parameter 'modificationid' cannot be null.");
        else if (modificationid !== undefined)
            url_ += "modificationid=" + encodeURIComponent("" + modificationid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCar_GetСarDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCar_GetСarDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CarDetailResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CarDetailResponse>;
        }));
    }

    protected processCar_GetСarDetails(response: HttpResponseBase): Observable<CarDetailResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CarDetailResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получение списка акционных запчастей по id модификации
     * @param request Запрос
     */
    sparePart_GetAllSalesSpareParts(request: SparePartRequest): Observable<FullTecDocResponse> {
        let url_ = this.baseUrl + "/api/SparePart/SalesByMod";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSparePart_GetAllSalesSpareParts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSparePart_GetAllSalesSpareParts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FullTecDocResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FullTecDocResponse>;
        }));
    }

    protected processSparePart_GetAllSalesSpareParts(response: HttpResponseBase): Observable<FullTecDocResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as FullTecDocResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получение списка запчастей по id модификации и id категории
     * @param request Запрос
     */
    sparePart_GetAllSpareParts(request: SparePartRequest): Observable<FullTecDocResponse> {
        let url_ = this.baseUrl + "/api/SparePart/AllByCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSparePart_GetAllSpareParts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSparePart_GetAllSpareParts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FullTecDocResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FullTecDocResponse>;
        }));
    }

    protected processSparePart_GetAllSpareParts(response: HttpResponseBase): Observable<FullTecDocResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as FullTecDocResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получение списка запчастей по артикулу запчасти
     * @param partnumber (optional) Артикул запчасти
     */
    sparePart_GetAllByPartNumber(partnumber: string | null | undefined): Observable<TecDocFullSparePart[]> {
        let url_ = this.baseUrl + "/api/SparePart/AllByNumber?";
        if (partnumber !== undefined && partnumber !== null)
            url_ += "partnumber=" + encodeURIComponent("" + partnumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSparePart_GetAllByPartNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSparePart_GetAllByPartNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TecDocFullSparePart[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TecDocFullSparePart[]>;
        }));
    }

    protected processSparePart_GetAllByPartNumber(response: HttpResponseBase): Observable<TecDocFullSparePart[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TecDocFullSparePart[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получение полного дерева категорий
     * @param modificationid Id модификации
     */
    sparePart_GetAllCategories(modificationid: number): Observable<TecDocCategoryFullResponse> {
        let url_ = this.baseUrl + "/api/SparePart/Categories/{modificationid}";
        if (modificationid === undefined || modificationid === null)
            throw new Error("The parameter 'modificationid' must be defined.");
        url_ = url_.replace("{modificationid}", encodeURIComponent("" + modificationid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSparePart_GetAllCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSparePart_GetAllCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TecDocCategoryFullResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TecDocCategoryFullResponse>;
        }));
    }

    protected processSparePart_GetAllCategories(response: HttpResponseBase): Observable<TecDocCategoryFullResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TecDocCategoryFullResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Добавление или обновление новости или акции
     * @param title (optional)
     * @param annonse (optional)
     * @param description (optional)
     * @param metaTitle (optional)
     * @param metaKeywords (optional)
     * @param metaDescription (optional)
     * @param isActive (optional)
     * @param type (optional)
     * @param isMain (optional)
     * @param stringKey (optional)
     * @param file (optional)
     */
    adminArticle_AddOrUpdate(title: string | null | undefined, annonse: string | null | undefined, description: string | null | undefined, metaTitle: string | null | undefined, metaKeywords: string | null | undefined, metaDescription: string | null | undefined, isActive: boolean | undefined, type: ArticleEnum | undefined, isMain: boolean | undefined, stringKey: string | null | undefined, file: string | null | undefined): Observable<ArticleResponse> {
        let url_ = this.baseUrl + "/api/AdminArticle/articles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (title !== null && title !== undefined)
            content_.append("Title", title.toString());
        if (annonse !== null && annonse !== undefined)
            content_.append("Annonse", annonse.toString());
        if (description !== null && description !== undefined)
            content_.append("Description", description.toString());
        if (metaTitle !== null && metaTitle !== undefined)
            content_.append("MetaTitle", metaTitle.toString());
        if (metaKeywords !== null && metaKeywords !== undefined)
            content_.append("MetaKeywords", metaKeywords.toString());
        if (metaDescription !== null && metaDescription !== undefined)
            content_.append("MetaDescription", metaDescription.toString());
        if (isActive === null || isActive === undefined)
            throw new Error("The parameter 'isActive' cannot be null.");
        else
            content_.append("IsActive", isActive.toString());
        if (type === null || type === undefined)
            throw new Error("The parameter 'type' cannot be null.");
        else
            content_.append("Type", type.toString());
        if (isMain === null || isMain === undefined)
            throw new Error("The parameter 'isMain' cannot be null.");
        else
            content_.append("IsMain", isMain.toString());
        if (stringKey !== null && stringKey !== undefined)
            content_.append("StringKey", stringKey.toString());
        if (file !== null && file !== undefined)
            content_.append("File", file.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminArticle_AddOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminArticle_AddOrUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ArticleResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ArticleResponse>;
        }));
    }

    protected processAdminArticle_AddOrUpdate(response: HttpResponseBase): Observable<ArticleResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ArticleResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Удалить новость или акцию по id
     */
    adminArticle_RemoveItemById(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AdminArticle/articles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminArticle_RemoveItemById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminArticle_RemoveItemById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAdminArticle_RemoveItemById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить ОС
     */
    adminBrand_Brands(binding: AdminBrandRequest): Observable<AdminBrandHelper> {
        let url_ = this.baseUrl + "/api/AdminBrand/brands";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminBrand_Brands(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminBrand_Brands(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminBrandHelper>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminBrandHelper>;
        }));
    }

    protected processAdminBrand_Brands(response: HttpResponseBase): Observable<AdminBrandHelper> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminBrandHelper;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить инфо по id
     */
    adminBrand_BrandById(id: number): Observable<AdminBrandHelperResponse> {
        let url_ = this.baseUrl + "/api/AdminBrand/brands/item/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminBrand_BrandById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminBrand_BrandById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminBrandHelperResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminBrandHelperResponse>;
        }));
    }

    protected processAdminBrand_BrandById(response: HttpResponseBase): Observable<AdminBrandHelperResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminBrandHelperResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * обновить инфо по id
     */
    adminBrand_BrandAddOrUpdate(binding: AdminBrandAddOrUpdate): Observable<AdminBrandResponse> {
        let url_ = this.baseUrl + "/api/AdminBrand/brands/item";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminBrand_BrandAddOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminBrand_BrandAddOrUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminBrandResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminBrandResponse>;
        }));
    }

    protected processAdminBrand_BrandAddOrUpdate(response: HttpResponseBase): Observable<AdminBrandResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminBrandResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить запрещенные бренды из TecDoc
     */
    adminBrand_Blacklist(): Observable<AdminTecDocBrandBlackListResponse[]> {
        let url_ = this.baseUrl + "/api/AdminBrand/brands/tecdoc/blacklist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminBrand_Blacklist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminBrand_Blacklist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminTecDocBrandBlackListResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminTecDocBrandBlackListResponse[]>;
        }));
    }

    protected processAdminBrand_Blacklist(response: HttpResponseBase): Observable<AdminTecDocBrandBlackListResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminTecDocBrandBlackListResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Обновить запрещенные бренды из TecDoc
     */
    adminBrand_BlacklistUpdate(binding: AdminTecDocBrandBlackListAddOrUpdate): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AdminBrand/brands/tecdoc/blacklist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminBrand_BlacklistUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminBrand_BlacklistUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAdminBrand_BlacklistUpdate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Обновить запрещенные бренды из TecDoc из 1С
     */
    adminBrand_BlacklistUpdateVia1C(tecDocBrandIds: number[]): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AdminBrand/brands/tecdoc/blacklist1c";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tecDocBrandIds);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminBrand_BlacklistUpdateVia1C(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminBrand_BlacklistUpdateVia1C(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAdminBrand_BlacklistUpdateVia1C(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить ОС
     */
    adminCategory_Categories(binding: AdminCategoryRequest): Observable<AdminCategoryHelper> {
        let url_ = this.baseUrl + "/api/AdminCategory/categories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminCategory_Categories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminCategory_Categories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminCategoryHelper>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminCategoryHelper>;
        }));
    }

    protected processAdminCategory_Categories(response: HttpResponseBase): Observable<AdminCategoryHelper> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminCategoryHelper;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить инфо по id
     */
    adminCategory_CategoryById(id: string): Observable<AdminCategoryResponse> {
        let url_ = this.baseUrl + "/api/AdminCategory/categories/item/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminCategory_CategoryById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminCategory_CategoryById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminCategoryResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminCategoryResponse>;
        }));
    }

    protected processAdminCategory_CategoryById(response: HttpResponseBase): Observable<AdminCategoryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminCategoryResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * обновить инфо по id
     * @param id (optional)
     * @param id1C (optional)
     * @param title (optional)
     * @param description (optional)
     * @param fullDescription (optional)
     * @param seoTitle (optional)
     * @param seoDescription (optional)
     * @param seoKeywords (optional)
     * @param parentId (optional)
     * @param parentId1C (optional)
     * @param isSale (optional)
     * @param isActive (optional)
     * @param file (optional)
     */
    adminCategory_CategoryAddOrUpdate(id: string | null | undefined, id1C: string | null | undefined, title: string | null | undefined, description: string | null | undefined, fullDescription: string | null | undefined, seoTitle: string | null | undefined, seoDescription: string | null | undefined, seoKeywords: string | null | undefined, parentId: string | null | undefined, parentId1C: string | null | undefined, isSale: boolean | undefined, isActive: boolean | undefined, file: string | null | undefined): Observable<AdminCategoryResponse> {
        let url_ = this.baseUrl + "/api/AdminCategory/categories/item";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id !== null && id !== undefined)
            content_.append("Id", id.toString());
        if (id1C !== null && id1C !== undefined)
            content_.append("Id1C", id1C.toString());
        if (title !== null && title !== undefined)
            content_.append("Title", title.toString());
        if (description !== null && description !== undefined)
            content_.append("Description", description.toString());
        if (fullDescription !== null && fullDescription !== undefined)
            content_.append("FullDescription", fullDescription.toString());
        if (seoTitle !== null && seoTitle !== undefined)
            content_.append("SeoTitle", seoTitle.toString());
        if (seoDescription !== null && seoDescription !== undefined)
            content_.append("SeoDescription", seoDescription.toString());
        if (seoKeywords !== null && seoKeywords !== undefined)
            content_.append("SeoKeywords", seoKeywords.toString());
        if (parentId !== null && parentId !== undefined)
            content_.append("ParentId", parentId.toString());
        if (parentId1C !== null && parentId1C !== undefined)
            content_.append("ParentId1C", parentId1C.toString());
        if (isSale === null || isSale === undefined)
            throw new Error("The parameter 'isSale' cannot be null.");
        else
            content_.append("IsSale", isSale.toString());
        if (isActive === null || isActive === undefined)
            throw new Error("The parameter 'isActive' cannot be null.");
        else
            content_.append("IsActive", isActive.toString());
        if (file !== null && file !== undefined)
            content_.append("File", file.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminCategory_CategoryAddOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminCategory_CategoryAddOrUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminCategoryResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminCategoryResponse>;
        }));
    }

    protected processAdminCategory_CategoryAddOrUpdate(response: HttpResponseBase): Observable<AdminCategoryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminCategoryResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Смена позиции
     * @param firstId (optional)
     * @param secondId (optional) file
     */
    adminCategory_ChangePosition(firstId: string | undefined, secondId: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AdminCategory/categories/position";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (firstId === null || firstId === undefined)
            throw new Error("The parameter 'firstId' cannot be null.");
        else
            content_.append("firstId", firstId.toString());
        if (secondId === null || secondId === undefined)
            throw new Error("The parameter 'secondId' cannot be null.");
        else
            content_.append("secondId", secondId.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminCategory_ChangePosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminCategory_ChangePosition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAdminCategory_ChangePosition(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить чаты
     */
    adminChat_ShortChats(binding: AdminShortChatRequest): Observable<AdminShortChatHelper> {
        let url_ = this.baseUrl + "/api/AdminChat/chats/left";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminChat_ShortChats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminChat_ShortChats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminShortChatHelper>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminShortChatHelper>;
        }));
    }

    protected processAdminChat_ShortChats(response: HttpResponseBase): Observable<AdminShortChatHelper> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminShortChatHelper;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * обновить чаты
     */
    adminChat_ShortChatsVisible(userIds: string[]): Observable<AdminShortChatResponse[]> {
        let url_ = this.baseUrl + "/api/AdminChat/chats/left/visible";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userIds);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminChat_ShortChatsVisible(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminChat_ShortChatsVisible(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminShortChatResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminShortChatResponse[]>;
        }));
    }

    protected processAdminChat_ShortChatsVisible(response: HttpResponseBase): Observable<AdminShortChatResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminShortChatResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить чаты
     * @param userIdQuery (optional)
     */
    adminChat_UpdateShortChats(userIdQuery: string | undefined, userIdPath: string): Observable<AdminShortChatResponse> {
        let url_ = this.baseUrl + "/api/AdminChat/chats/left/{userId}?";
        if (userIdPath === undefined || userIdPath === null)
            throw new Error("The parameter 'userIdPath' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userIdPath));
        if (userIdQuery === null)
            throw new Error("The parameter 'userIdQuery' cannot be null.");
        else if (userIdQuery !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userIdQuery) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminChat_UpdateShortChats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminChat_UpdateShortChats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminShortChatResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminShortChatResponse>;
        }));
    }

    protected processAdminChat_UpdateShortChats(response: HttpResponseBase): Observable<AdminShortChatResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminShortChatResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить чат пользователя
     */
    adminChat_UserChatInfo(binding: AdminChatInfoRequest): Observable<AdminChatInfoHelper> {
        let url_ = this.baseUrl + "/api/AdminChat/chats/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminChat_UserChatInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminChat_UserChatInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminChatInfoHelper>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminChatInfoHelper>;
        }));
    }

    protected processAdminChat_UserChatInfo(response: HttpResponseBase): Observable<AdminChatInfoHelper> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminChatInfoHelper;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Чаты пользователя обновить читаемость
     * @param userId Идентификатор пользователя
     */
    adminChat_UpdateRead(userId: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AdminChat/chats/read/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminChat_UpdateRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminChat_UpdateRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAdminChat_UpdateRead(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Чаты пользователя добавить сообщение
     * @param binding Тело запроса
     */
    adminChat_SendMessage(binding: AdminMessageSendRequest): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AdminChat/chats/send/support";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminChat_SendMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminChat_SendMessage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAdminChat_SendMessage(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Чаты пользователя добавить сообщение не админ
     */
    adminChat_SendMessageClient(binding: MessageSendRequest): Observable<ChatResponse> {
        let url_ = this.baseUrl + "/api/AdminChat/chats/send";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminChat_SendMessageClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminChat_SendMessageClient(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatResponse>;
        }));
    }

    protected processAdminChat_SendMessageClient(response: HttpResponseBase): Observable<ChatResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ChatResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Чаты пользователя обновить видимость
     */
    adminChat_UpdateChat(binding: AdminChatUserUpdateRequest): Observable<ChatResponse[]> {
        let url_ = this.baseUrl + "/api/AdminChat/chats/user/receiver";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminChat_UpdateChat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminChat_UpdateChat(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatResponse[]>;
        }));
    }

    protected processAdminChat_UpdateChat(response: HttpResponseBase): Observable<ChatResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ChatResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Чаты пользователя обновить видимые
     */
    adminChat_UpdateChatVisibility(ids: string[]): Observable<ChatResponse[]> {
        let url_ = this.baseUrl + "/api/AdminChat/chats/user/visibility";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminChat_UpdateChatVisibility(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminChat_UpdateChatVisibility(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatResponse[]>;
        }));
    }

    protected processAdminChat_UpdateChatVisibility(response: HttpResponseBase): Observable<ChatResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ChatResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить ОС
     */
    adminContactUs_Contacts(binding: AdminContactUsRequest): Observable<AdminContactUsHelper> {
        let url_ = this.baseUrl + "/api/AdminContactUs/contactus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminContactUs_Contacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminContactUs_Contacts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminContactUsHelper>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminContactUsHelper>;
        }));
    }

    protected processAdminContactUs_Contacts(response: HttpResponseBase): Observable<AdminContactUsHelper> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminContactUsHelper;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить ОС по id
     */
    adminContactUs_ContactUpdate(binding: AdminContactUsUpdateRequest): Observable<AdminContactUsResponse> {
        let url_ = this.baseUrl + "/api/AdminContactUs/contactus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminContactUs_ContactUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminContactUs_ContactUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminContactUsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminContactUsResponse>;
        }));
    }

    protected processAdminContactUs_ContactUpdate(response: HttpResponseBase): Observable<AdminContactUsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminContactUsResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить ОС по id
     */
    adminContactUs_Contact(id: string): Observable<AdminContactUsResponse> {
        let url_ = this.baseUrl + "/api/AdminContactUs/contactus/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminContactUs_Contact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminContactUs_Contact(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminContactUsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminContactUsResponse>;
        }));
    }

    protected processAdminContactUs_Contact(response: HttpResponseBase): Observable<AdminContactUsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminContactUsResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Удалить OC id
     */
    adminContactUs_RemoveItemById(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AdminContactUs/sto/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminContactUs_RemoveItemById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminContactUs_RemoveItemById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAdminContactUs_RemoveItemById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить ОС
     */
    adminCountry_CountriesAll(binding: AdminCountryRequest): Observable<AdminCountryHelper> {
        let url_ = this.baseUrl + "/api/AdminCountry/countries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminCountry_CountriesAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminCountry_CountriesAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminCountryHelper>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminCountryHelper>;
        }));
    }

    protected processAdminCountry_CountriesAll(response: HttpResponseBase): Observable<AdminCountryHelper> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminCountryHelper;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить инфо по id
     */
    adminCountry_CountryById(id: number): Observable<AdminCountryResponse> {
        let url_ = this.baseUrl + "/api/AdminCountry/countries/item/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminCountry_CountryById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminCountry_CountryById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminCountryResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminCountryResponse>;
        }));
    }

    protected processAdminCountry_CountryById(response: HttpResponseBase): Observable<AdminCountryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminCountryResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * обновить инфо по id
     */
    adminCountry_CountryAddOrUpdate(binding: AdminCountryAddOrUpdate): Observable<AdminCountryResponse> {
        let url_ = this.baseUrl + "/api/AdminCountry/countries/item";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminCountry_CountryAddOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminCountry_CountryAddOrUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminCountryResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminCountryResponse>;
        }));
    }

    protected processAdminCountry_CountryAddOrUpdate(response: HttpResponseBase): Observable<AdminCountryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminCountryResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить ОС
     */
    adminCountry_CityAll(binding: AdminCityRequest): Observable<AdminCityHelper> {
        let url_ = this.baseUrl + "/api/AdminCountry/cities";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminCountry_CityAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminCountry_CityAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminCityHelper>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminCityHelper>;
        }));
    }

    protected processAdminCountry_CityAll(response: HttpResponseBase): Observable<AdminCityHelper> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminCityHelper;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить инфо по id
     */
    adminCountry_CityById(id: number): Observable<AdminCityResponse> {
        let url_ = this.baseUrl + "/api/AdminCountry/cities/item/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminCountry_CityById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminCountry_CityById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminCityResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminCityResponse>;
        }));
    }

    protected processAdminCountry_CityById(response: HttpResponseBase): Observable<AdminCityResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminCityResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * обновить инфо по id
     */
    adminCountry_CityAddOrUpdate(binding: AdminCityAddOrUpdate): Observable<AdminCityResponse> {
        let url_ = this.baseUrl + "/api/AdminCountry/cities/item";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminCountry_CityAddOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminCountry_CityAddOrUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminCityResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminCityResponse>;
        }));
    }

    protected processAdminCountry_CityAddOrUpdate(response: HttpResponseBase): Observable<AdminCityResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminCityResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * смена позиции города
     * @param firstId (optional)
     * @param secondId (optional)
     */
    adminCountry_CityChangePosition(firstId: number | undefined, secondId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AdminCountry/cities/position";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (firstId === null || firstId === undefined)
            throw new Error("The parameter 'firstId' cannot be null.");
        else
            content_.append("firstId", firstId.toString());
        if (secondId === null || secondId === undefined)
            throw new Error("The parameter 'secondId' cannot be null.");
        else
            content_.append("secondId", secondId.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminCountry_CityChangePosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminCountry_CityChangePosition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAdminCountry_CityChangePosition(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить категории инфы для скачивания
     */
    adminDownloadInfo_DownloadInfo(binding: AdminDownloadInfoRequest): Observable<AdminDownloadInfoHelper> {
        let url_ = this.baseUrl + "/api/AdminDownloadInfo/downloadinfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminDownloadInfo_DownloadInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminDownloadInfo_DownloadInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminDownloadInfoHelper>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminDownloadInfoHelper>;
        }));
    }

    protected processAdminDownloadInfo_DownloadInfo(response: HttpResponseBase): Observable<AdminDownloadInfoHelper> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminDownloadInfoHelper;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * обновить категорию инфо по id
     * @param id (optional)
     * @param title (optional)
     * @param image (optional)
     * @param isActive (optional)
     */
    adminDownloadInfo_DownloadInfoUpdate(id: string | null | undefined, title: string | null | undefined, image: string | null | undefined, isActive: boolean | undefined): Observable<AdminDownloadInfoResponse> {
        let url_ = this.baseUrl + "/api/AdminDownloadInfo/downloadinfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id !== null && id !== undefined)
            content_.append("Id", id.toString());
        if (title !== null && title !== undefined)
            content_.append("Title", title.toString());
        if (image !== null && image !== undefined)
            content_.append("Image", image.toString());
        if (isActive === null || isActive === undefined)
            throw new Error("The parameter 'isActive' cannot be null.");
        else
            content_.append("IsActive", isActive.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminDownloadInfo_DownloadInfoUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminDownloadInfo_DownloadInfoUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminDownloadInfoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminDownloadInfoResponse>;
        }));
    }

    protected processAdminDownloadInfo_DownloadInfoUpdate(response: HttpResponseBase): Observable<AdminDownloadInfoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminDownloadInfoResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить инфо для скачивания
     */
    adminDownloadInfo_DownloadInfoItem(binding: AdminDownloadInfoItemRequest): Observable<AdminDownloadInfoItemHelper> {
        let url_ = this.baseUrl + "/api/AdminDownloadInfo/downloadinfo/items";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminDownloadInfo_DownloadInfoItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminDownloadInfo_DownloadInfoItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminDownloadInfoItemHelper>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminDownloadInfoItemHelper>;
        }));
    }

    protected processAdminDownloadInfo_DownloadInfoItem(response: HttpResponseBase): Observable<AdminDownloadInfoItemHelper> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminDownloadInfoItemHelper;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить инфо для скачивания
     */
    adminDownloadInfo_DownloadInfoCategory(): Observable<AdminDownloadInfoResponse[]> {
        let url_ = this.baseUrl + "/api/AdminDownloadInfo/downloadinfo/category";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminDownloadInfo_DownloadInfoCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminDownloadInfo_DownloadInfoCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminDownloadInfoResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminDownloadInfoResponse[]>;
        }));
    }

    protected processAdminDownloadInfo_DownloadInfoCategory(response: HttpResponseBase): Observable<AdminDownloadInfoResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminDownloadInfoResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить категорию инфо по stringKey
     */
    adminDownloadInfo_DownloadInfoStringKey(stringKey: string): Observable<AdminDownloadInfoResponse> {
        let url_ = this.baseUrl + "/api/AdminDownloadInfo/downloadinfo/{stringKey}";
        if (stringKey === undefined || stringKey === null)
            throw new Error("The parameter 'stringKey' must be defined.");
        url_ = url_.replace("{stringKey}", encodeURIComponent("" + stringKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminDownloadInfo_DownloadInfoStringKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminDownloadInfo_DownloadInfoStringKey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminDownloadInfoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminDownloadInfoResponse>;
        }));
    }

    protected processAdminDownloadInfo_DownloadInfoStringKey(response: HttpResponseBase): Observable<AdminDownloadInfoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminDownloadInfoResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить инфо по stringKey
     */
    adminDownloadInfo_DownloadInfoItemStringKey(stringKey: string): Observable<AdminDownloadInfoItemResponse> {
        let url_ = this.baseUrl + "/api/AdminDownloadInfo/downloadinfo/item/{stringKey}";
        if (stringKey === undefined || stringKey === null)
            throw new Error("The parameter 'stringKey' must be defined.");
        url_ = url_.replace("{stringKey}", encodeURIComponent("" + stringKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminDownloadInfo_DownloadInfoItemStringKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminDownloadInfo_DownloadInfoItemStringKey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminDownloadInfoItemResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminDownloadInfoItemResponse>;
        }));
    }

    protected processAdminDownloadInfo_DownloadInfoItemStringKey(response: HttpResponseBase): Observable<AdminDownloadInfoItemResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminDownloadInfoItemResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * обновить инфо по id
     * @param id (optional)
     * @param title (optional)
     * @param file (optional)
     * @param fileSize (optional)
     * @param image (optional)
     * @param isActive (optional)
     * @param downloadInfoId (optional)
     */
    adminDownloadInfo_DownloadInfoItemUpdate(id: string | null | undefined, title: string | null | undefined, file: string | null | undefined, fileSize: number | undefined, image: string | null | undefined, isActive: boolean | undefined, downloadInfoId: string | undefined): Observable<AdminDownloadInfoItemResponse> {
        let url_ = this.baseUrl + "/api/AdminDownloadInfo/downloadinfo/item";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id !== null && id !== undefined)
            content_.append("Id", id.toString());
        if (title !== null && title !== undefined)
            content_.append("Title", title.toString());
        if (file !== null && file !== undefined)
            content_.append("File", file.toString());
        if (fileSize === null || fileSize === undefined)
            throw new Error("The parameter 'fileSize' cannot be null.");
        else
            content_.append("FileSize", fileSize.toString());
        if (image !== null && image !== undefined)
            content_.append("Image", image.toString());
        if (isActive === null || isActive === undefined)
            throw new Error("The parameter 'isActive' cannot be null.");
        else
            content_.append("IsActive", isActive.toString());
        if (downloadInfoId === null || downloadInfoId === undefined)
            throw new Error("The parameter 'downloadInfoId' cannot be null.");
        else
            content_.append("DownloadInfoId", downloadInfoId.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminDownloadInfo_DownloadInfoItemUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminDownloadInfo_DownloadInfoItemUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminDownloadInfoItemResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminDownloadInfoItemResponse>;
        }));
    }

    protected processAdminDownloadInfo_DownloadInfoItemUpdate(response: HttpResponseBase): Observable<AdminDownloadInfoItemResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminDownloadInfoItemResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить маршруты
     */
    adminLogistic_Routes(binding: AdminRouteRequest): Observable<AdminRouteHelper> {
        let url_ = this.baseUrl + "/api/AdminLogistic/routes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminLogistic_Routes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminLogistic_Routes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminRouteHelper>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminRouteHelper>;
        }));
    }

    protected processAdminLogistic_Routes(response: HttpResponseBase): Observable<AdminRouteHelper> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminRouteHelper;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * обновить маршрут по id
     */
    adminLogistic_RouteAddOrUpdate(binding: AdminRouteAddOrUpdate): Observable<AdminRouteResponse> {
        let url_ = this.baseUrl + "/api/AdminLogistic/routes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminLogistic_RouteAddOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminLogistic_RouteAddOrUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminRouteResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminRouteResponse>;
        }));
    }

    protected processAdminLogistic_RouteAddOrUpdate(response: HttpResponseBase): Observable<AdminRouteResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminRouteResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить маршрут по id
     */
    adminLogistic_RouteById(id: number): Observable<AdminRouteResponse> {
        let url_ = this.baseUrl + "/api/AdminLogistic/routes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminLogistic_RouteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminLogistic_RouteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminRouteResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminRouteResponse>;
        }));
    }

    protected processAdminLogistic_RouteById(response: HttpResponseBase): Observable<AdminRouteResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminRouteResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить сектора
     */
    adminLogistic_Sectors(binding: AdminSectorRequest): Observable<AdminSectorHelper> {
        let url_ = this.baseUrl + "/api/AdminLogistic/sectors";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminLogistic_Sectors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminLogistic_Sectors(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminSectorHelper>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminSectorHelper>;
        }));
    }

    protected processAdminLogistic_Sectors(response: HttpResponseBase): Observable<AdminSectorHelper> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminSectorHelper;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * обновить сектор по id
     */
    adminLogistic_SectorAddOrUpdate(binding: AdminSectorAddOrUpdate): Observable<AdminSectorResponse> {
        let url_ = this.baseUrl + "/api/AdminLogistic/sectors";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminLogistic_SectorAddOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminLogistic_SectorAddOrUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminSectorResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminSectorResponse>;
        }));
    }

    protected processAdminLogistic_SectorAddOrUpdate(response: HttpResponseBase): Observable<AdminSectorResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminSectorResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить сектор по id
     */
    adminLogistic_SectorById(id: number): Observable<AdminSectorResponse> {
        let url_ = this.baseUrl + "/api/AdminLogistic/sectors/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminLogistic_SectorById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminLogistic_SectorById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminSectorResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminSectorResponse>;
        }));
    }

    protected processAdminLogistic_SectorById(response: HttpResponseBase): Observable<AdminSectorResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminSectorResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить ОС
     */
    adminOption_OptionsAll(binding: AdminOptionRequest): Observable<AdminOptionHelper> {
        let url_ = this.baseUrl + "/api/AdminOption/options";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminOption_OptionsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminOption_OptionsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminOptionHelper>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminOptionHelper>;
        }));
    }

    protected processAdminOption_OptionsAll(response: HttpResponseBase): Observable<AdminOptionHelper> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminOptionHelper;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить инфо по id
     */
    adminOption_OptionById(id: string): Observable<AdminOptionHelperResponse> {
        let url_ = this.baseUrl + "/api/AdminOption/options/item/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminOption_OptionById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminOption_OptionById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminOptionHelperResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminOptionHelperResponse>;
        }));
    }

    protected processAdminOption_OptionById(response: HttpResponseBase): Observable<AdminOptionHelperResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminOptionHelperResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * обновить инфо по id
     */
    adminOption_OptionAddOrUpdate(binding: AdminOptionAddOrUpdate): Observable<AdminOptionResponse> {
        let url_ = this.baseUrl + "/api/AdminOption/options/item";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminOption_OptionAddOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminOption_OptionAddOrUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminOptionResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminOptionResponse>;
        }));
    }

    protected processAdminOption_OptionAddOrUpdate(response: HttpResponseBase): Observable<AdminOptionResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminOptionResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Смена позиции
     * @param firstId (optional)
     * @param secondId (optional) file
     */
    adminOption_ChangeOptionPosition(firstId: string | undefined, secondId: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AdminOption/options/position";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (firstId === null || firstId === undefined)
            throw new Error("The parameter 'firstId' cannot be null.");
        else
            content_.append("firstId", firstId.toString());
        if (secondId === null || secondId === undefined)
            throw new Error("The parameter 'secondId' cannot be null.");
        else
            content_.append("secondId", secondId.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminOption_ChangeOptionPosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminOption_ChangeOptionPosition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAdminOption_ChangeOptionPosition(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Смена позиции
     * @param firstId (optional)
     * @param secondId (optional) file
     */
    adminOption_ChangeValuePosition(firstId: string | undefined, secondId: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AdminOption/options/values/position";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (firstId === null || firstId === undefined)
            throw new Error("The parameter 'firstId' cannot be null.");
        else
            content_.append("firstId", firstId.toString());
        if (secondId === null || secondId === undefined)
            throw new Error("The parameter 'secondId' cannot be null.");
        else
            content_.append("secondId", secondId.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminOption_ChangeValuePosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminOption_ChangeValuePosition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAdminOption_ChangeValuePosition(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить ОС
     */
    adminOption_OptionValuesAll(binding: AdminOptionValueRequest): Observable<AdminOptionValueResponse[]> {
        let url_ = this.baseUrl + "/api/AdminOption/options/values";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminOption_OptionValuesAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminOption_OptionValuesAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminOptionValueResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminOptionValueResponse[]>;
        }));
    }

    protected processAdminOption_OptionValuesAll(response: HttpResponseBase): Observable<AdminOptionValueResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminOptionValueResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить инфо по id
     */
    adminOption_OptionValueById(id: string): Observable<AdminOptionValueResponse> {
        let url_ = this.baseUrl + "/api/AdminOption/options/values/item/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminOption_OptionValueById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminOption_OptionValueById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminOptionValueResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminOptionValueResponse>;
        }));
    }

    protected processAdminOption_OptionValueById(response: HttpResponseBase): Observable<AdminOptionValueResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminOptionValueResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * обновить инфо по id
     */
    adminOption_OptionValueAddOrUpdate(binding: AdminOptionValueAddOrUpdate): Observable<AdminOptionValueResponse> {
        let url_ = this.baseUrl + "/api/AdminOption/options/values/item";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminOption_OptionValueAddOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminOption_OptionValueAddOrUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminOptionValueResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminOptionValueResponse>;
        }));
    }

    protected processAdminOption_OptionValueAddOrUpdate(response: HttpResponseBase): Observable<AdminOptionValueResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminOptionValueResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить заказы
     */
    adminOrder_Orders(binding: AdminOrderRequest): Observable<AdminOrderHelper> {
        let url_ = this.baseUrl + "/api/AdminOrder/orders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminOrder_Orders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminOrder_Orders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminOrderHelper>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminOrderHelper>;
        }));
    }

    protected processAdminOrder_Orders(response: HttpResponseBase): Observable<AdminOrderHelper> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminOrderHelper;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить заказ по id
     */
    adminOrder_OrderById(id: number): Observable<AdminOrderResponse> {
        let url_ = this.baseUrl + "/api/AdminOrder/routes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminOrder_OrderById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminOrder_OrderById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminOrderResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminOrderResponse>;
        }));
    }

    protected processAdminOrder_OrderById(response: HttpResponseBase): Observable<AdminOrderResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminOrderResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Обновить заказ по id
     */
    adminOrder_OrderAddOrUpdate(binding: AdminOrderAddOrUpdate): Observable<AdminOrderResponse> {
        let url_ = this.baseUrl + "/api/AdminOrder/routes/items";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminOrder_OrderAddOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminOrder_OrderAddOrUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminOrderResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminOrderResponse>;
        }));
    }

    protected processAdminOrder_OrderAddOrUpdate(response: HttpResponseBase): Observable<AdminOrderResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminOrderResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Обновить валюту заказа
     */
    adminOrder_OrderChangeCurrency(binding: AdminOrderCurrencyChangeRequest): Observable<AdminOrderProdcutResponse[]> {
        let url_ = this.baseUrl + "/api/AdminOrder/orders/currency";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminOrder_OrderChangeCurrency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminOrder_OrderChangeCurrency(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminOrderProdcutResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminOrderProdcutResponse[]>;
        }));
    }

    protected processAdminOrder_OrderChangeCurrency(response: HttpResponseBase): Observable<AdminOrderProdcutResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminOrderProdcutResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Отменить заказ
     */
    adminOrder_RejectOrder(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AdminOrder/orders/reject/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminOrder_RejectOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminOrder_RejectOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAdminOrder_RejectOrder(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Отменить заказ 1c
     */
    adminOrder_RejectOrder1C(id1C: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AdminOrder/orders/reject/1c/{id1C}";
        if (id1C === undefined || id1C === null)
            throw new Error("The parameter 'id1C' must be defined.");
        url_ = url_.replace("{id1C}", encodeURIComponent("" + id1C));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminOrder_RejectOrder1C(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminOrder_RejectOrder1C(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAdminOrder_RejectOrder1C(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить страницы
     */
    adminPage_Pages(binding: AdminPageRequest): Observable<AdminPageHelper> {
        let url_ = this.baseUrl + "/api/AdminPage/pages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminPage_Pages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminPage_Pages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminPageHelper>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminPageHelper>;
        }));
    }

    protected processAdminPage_Pages(response: HttpResponseBase): Observable<AdminPageHelper> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminPageHelper;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * обновить страницу по id
     */
    adminPage_PageUpdate(binding: AdminPageUpdateRequest): Observable<AdminPageResponse> {
        let url_ = this.baseUrl + "/api/AdminPage/pages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminPage_PageUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminPage_PageUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminPageResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminPageResponse>;
        }));
    }

    protected processAdminPage_PageUpdate(response: HttpResponseBase): Observable<AdminPageResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminPageResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить страницу по id
     */
    adminPage_PageById(id: number): Observable<AdminPageResponse> {
        let url_ = this.baseUrl + "/api/AdminPage/pages/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminPage_PageById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminPage_PageById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminPageResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminPageResponse>;
        }));
    }

    protected processAdminPage_PageById(response: HttpResponseBase): Observable<AdminPageResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminPageResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить партнеров
     */
    adminPartner_Partners(binding: AdminPartnerRequest): Observable<AdminPartnerHelper> {
        let url_ = this.baseUrl + "/api/AdminPartner/partners";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminPartner_Partners(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminPartner_Partners(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminPartnerHelper>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminPartnerHelper>;
        }));
    }

    protected processAdminPartner_Partners(response: HttpResponseBase): Observable<AdminPartnerHelper> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminPartnerHelper;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * обновить партнера по id
     * @param id (optional)
     * @param id1C (optional)
     * @param isActive (optional)
     * @param name (optional)
     * @param description (optional)
     * @param url (optional)
     * @param country (optional)
     * @param file (optional)
     */
    adminPartner_PartnerUpdate(id: number | undefined, id1C: string | null | undefined, isActive: boolean | undefined, name: string | null | undefined, description: string | null | undefined, url: string | null | undefined, country: string | null | undefined, file: string | null | undefined): Observable<AdminPartnerResponse> {
        let url_ = this.baseUrl + "/api/AdminPartner/partners";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (id1C !== null && id1C !== undefined)
            content_.append("Id1C", id1C.toString());
        if (isActive === null || isActive === undefined)
            throw new Error("The parameter 'isActive' cannot be null.");
        else
            content_.append("IsActive", isActive.toString());
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (description !== null && description !== undefined)
            content_.append("Description", description.toString());
        if (url !== null && url !== undefined)
            content_.append("Url", url.toString());
        if (country !== null && country !== undefined)
            content_.append("Country", country.toString());
        if (file !== null && file !== undefined)
            content_.append("File", file.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminPartner_PartnerUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminPartner_PartnerUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminPartnerResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminPartnerResponse>;
        }));
    }

    protected processAdminPartner_PartnerUpdate(response: HttpResponseBase): Observable<AdminPartnerResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminPartnerResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить партнера по id
     */
    adminPartner_PartnerById(id: number): Observable<AdminPartnerResponse> {
        let url_ = this.baseUrl + "/api/AdminPartner/partners/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminPartner_PartnerById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminPartner_PartnerById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminPartnerResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminPartnerResponse>;
        }));
    }

    protected processAdminPartner_PartnerById(response: HttpResponseBase): Observable<AdminPartnerResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminPartnerResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Смена позиции
     * @param firstId (optional)
     * @param secondId (optional) file
     */
    adminPartner_ChangePosition(firstId: number | undefined, secondId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AdminPartner/partner/position";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (firstId === null || firstId === undefined)
            throw new Error("The parameter 'firstId' cannot be null.");
        else
            content_.append("firstId", firstId.toString());
        if (secondId === null || secondId === undefined)
            throw new Error("The parameter 'secondId' cannot be null.");
        else
            content_.append("secondId", secondId.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminPartner_ChangePosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminPartner_ChangePosition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAdminPartner_ChangePosition(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить ОС
     */
    adminPhoneCounty_PhoneCountryAll(): Observable<AdminPhoneCountryResponse[]> {
        let url_ = this.baseUrl + "/api/AdminPhoneCounty/countries/phones";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminPhoneCounty_PhoneCountryAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminPhoneCounty_PhoneCountryAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminPhoneCountryResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminPhoneCountryResponse[]>;
        }));
    }

    protected processAdminPhoneCounty_PhoneCountryAll(response: HttpResponseBase): Observable<AdminPhoneCountryResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminPhoneCountryResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Обновить
     */
    adminPhoneCounty_PhoneCountryUpdate(binding: AdminPhoneCountryUpdateRequest[]): Observable<AdminPhoneCountryResponse[]> {
        let url_ = this.baseUrl + "/api/AdminPhoneCounty/countries/phones";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminPhoneCounty_PhoneCountryUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminPhoneCounty_PhoneCountryUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminPhoneCountryResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminPhoneCountryResponse[]>;
        }));
    }

    protected processAdminPhoneCounty_PhoneCountryUpdate(response: HttpResponseBase): Observable<AdminPhoneCountryResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminPhoneCountryResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить уровни цен
     */
    adminPriceLevel_PriceLevels(binding: AdminPriceLevelRequest): Observable<AdminPriceLevelHelper> {
        let url_ = this.baseUrl + "/api/AdminPriceLevel/pricelevels";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminPriceLevel_PriceLevels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminPriceLevel_PriceLevels(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminPriceLevelHelper>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminPriceLevelHelper>;
        }));
    }

    protected processAdminPriceLevel_PriceLevels(response: HttpResponseBase): Observable<AdminPriceLevelHelper> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminPriceLevelHelper;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * обновить уровень цен по id
     */
    adminPriceLevel_PriceLevelAddOrUpdate(binding: AdminPriceLevelAddOrUpdate): Observable<AdminPriceLevelResponse> {
        let url_ = this.baseUrl + "/api/AdminPriceLevel/pricelevels";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminPriceLevel_PriceLevelAddOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminPriceLevel_PriceLevelAddOrUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminPriceLevelResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminPriceLevelResponse>;
        }));
    }

    protected processAdminPriceLevel_PriceLevelAddOrUpdate(response: HttpResponseBase): Observable<AdminPriceLevelResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminPriceLevelResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить уровня цены по id
     */
    adminPriceLevel_PriceLevelById(id: number): Observable<AdminPriceLevelResponse> {
        let url_ = this.baseUrl + "/api/AdminPriceLevel/pricelevels/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminPriceLevel_PriceLevelById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminPriceLevel_PriceLevelById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminPriceLevelResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminPriceLevelResponse>;
        }));
    }

    protected processAdminPriceLevel_PriceLevelById(response: HttpResponseBase): Observable<AdminPriceLevelResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminPriceLevelResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить ОС
     */
    adminProduct_Products(binding: AdminProductRequest): Observable<AdminProductHelper> {
        let url_ = this.baseUrl + "/api/AdminProduct/products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminProduct_Products(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminProduct_Products(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminProductHelper>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminProductHelper>;
        }));
    }

    protected processAdminProduct_Products(response: HttpResponseBase): Observable<AdminProductHelper> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminProductHelper;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить инфо по id
     */
    adminProduct_ProductById(id: string): Observable<AdminProductResponse> {
        let url_ = this.baseUrl + "/api/AdminProduct/products/item/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminProduct_ProductById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminProduct_ProductById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminProductResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminProductResponse>;
        }));
    }

    protected processAdminProduct_ProductById(response: HttpResponseBase): Observable<AdminProductResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminProductResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Добавить фото
     * @param productId (optional)
     * @param id1C (optional)
     * @param file (optional)
     * @param isMain (optional)
     */
    adminProduct_AddProductImage(productId: string | undefined, id1C: string | null | undefined, file: string | null | undefined, isMain: boolean | undefined): Observable<AdminProductImageHelper> {
        let url_ = this.baseUrl + "/api/AdminProduct/products/images";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (productId === null || productId === undefined)
            throw new Error("The parameter 'productId' cannot be null.");
        else
            content_.append("ProductId", productId.toString());
        if (id1C !== null && id1C !== undefined)
            content_.append("Id1C", id1C.toString());
        if (file !== null && file !== undefined)
            content_.append("File", file.toString());
        if (isMain === null || isMain === undefined)
            throw new Error("The parameter 'isMain' cannot be null.");
        else
            content_.append("IsMain", isMain.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminProduct_AddProductImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminProduct_AddProductImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminProductImageHelper>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminProductImageHelper>;
        }));
    }

    protected processAdminProduct_AddProductImage(response: HttpResponseBase): Observable<AdminProductImageHelper> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminProductImageHelper;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Удалить фото
     */
    adminProduct_RemoveProductImage(imageId: string): Observable<string | null> {
        let url_ = this.baseUrl + "/api/AdminProduct/products/images/{imageId}";
        if (imageId === undefined || imageId === null)
            throw new Error("The parameter 'imageId' must be defined.");
        url_ = url_.replace("{imageId}", encodeURIComponent("" + imageId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminProduct_RemoveProductImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminProduct_RemoveProductImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string | null>;
        }));
    }

    protected processAdminProduct_RemoveProductImage(response: HttpResponseBase): Observable<string | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Обновить главное фото
     */
    adminProduct_UpdateMainProductImage(imageId: string, productId: string): Observable<string | null> {
        let url_ = this.baseUrl + "/api/AdminProduct/products/images/main/{imageId}/{productId}";
        if (imageId === undefined || imageId === null)
            throw new Error("The parameter 'imageId' must be defined.");
        url_ = url_.replace("{imageId}", encodeURIComponent("" + imageId));
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminProduct_UpdateMainProductImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminProduct_UpdateMainProductImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string | null>;
        }));
    }

    protected processAdminProduct_UpdateMainProductImage(response: HttpResponseBase): Observable<string | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Обновить или добавить товар
     */
    adminProduct_AddOrUpdateProduct(binding: AdminProductAddOrUpdate): Observable<string | null> {
        let url_ = this.baseUrl + "/api/AdminProduct/products/items";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminProduct_AddOrUpdateProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminProduct_AddOrUpdateProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string | null>;
        }));
    }

    protected processAdminProduct_AddOrUpdateProduct(response: HttpResponseBase): Observable<string | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить товар по articul
     */
    adminProduct_GetProductByArticul(binding: AdminProductArticulRequset): Observable<AdminOrderProdcutResponse> {
        let url_ = this.baseUrl + "/api/AdminProduct/orders/products/articul";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminProduct_GetProductByArticul(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminProduct_GetProductByArticul(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminOrderProdcutResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminOrderProdcutResponse>;
        }));
    }

    protected processAdminProduct_GetProductByArticul(response: HttpResponseBase): Observable<AdminOrderProdcutResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminOrderProdcutResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить настройки
     */
    adminSetting_AdminSettings(): Observable<SettingsResponse> {
        let url_ = this.baseUrl + "/api/AdminSetting/settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminSetting_AdminSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminSetting_AdminSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SettingsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SettingsResponse>;
        }));
    }

    protected processAdminSetting_AdminSettings(response: HttpResponseBase): Observable<SettingsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SettingsResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Сохранить настройки
     */
    adminSetting_ChangeSettings(binding: SettingResponse[]): Observable<SettingResponse[]> {
        let url_ = this.baseUrl + "/api/AdminSetting/settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminSetting_ChangeSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminSetting_ChangeSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SettingResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SettingResponse[]>;
        }));
    }

    protected processAdminSetting_ChangeSettings(response: HttpResponseBase): Observable<SettingResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SettingResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Сохранить соц сети
     */
    adminSetting_ChangeSocials(binding: SocialNetworkRequest[]): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AdminSetting/settings/social";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminSetting_ChangeSocials(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminSetting_ChangeSocials(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAdminSetting_ChangeSocials(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * badge для меню
     */
    adminSetting_BadgeCount(): Observable<AdminBadgeResponse> {
        let url_ = this.baseUrl + "/api/AdminSetting/badge";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminSetting_BadgeCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminSetting_BadgeCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminBadgeResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminBadgeResponse>;
        }));
    }

    protected processAdminSetting_BadgeCount(response: HttpResponseBase): Observable<AdminBadgeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminBadgeResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Инфо о пользователе
     */
    adminSetting_AdminInfo(): Observable<AdminUserProfileResponse> {
        let url_ = this.baseUrl + "/api/AdminSetting/manager/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminSetting_AdminInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminSetting_AdminInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminUserProfileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminUserProfileResponse>;
        }));
    }

    protected processAdminSetting_AdminInfo(response: HttpResponseBase): Observable<AdminUserProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminUserProfileResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Реиндексирование всех товаров для автоподстановки
     */
    adminSetting_ReIndex(): Observable<void> {
        let url_ = this.baseUrl + "/api/AdminSetting/ReindexProducts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminSetting_ReIndex(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminSetting_ReIndex(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAdminSetting_ReIndex(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Exception;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Реиндексирование всех категорий для автоподстановки
     */
    adminSetting_ReIndexCats(): Observable<void> {
        let url_ = this.baseUrl + "/api/AdminSetting/ReindexCategories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminSetting_ReIndexCats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminSetting_ReIndexCats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAdminSetting_ReIndexCats(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Exception;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Реиндексирование всех брендов
     */
    adminSetting_ReIndexBrands(): Observable<void> {
        let url_ = this.baseUrl + "/api/AdminSetting/ReindexBrands";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminSetting_ReIndexBrands(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminSetting_ReIndexBrands(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAdminSetting_ReIndexBrands(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Exception;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить города и страны
     */
    adminSetting_CountriesAll(): Observable<AdminCountryResponse[]> {
        let url_ = this.baseUrl + "/api/AdminSetting/countries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminSetting_CountriesAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminSetting_CountriesAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminCountryResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminCountryResponse[]>;
        }));
    }

    protected processAdminSetting_CountriesAll(response: HttpResponseBase): Observable<AdminCountryResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminCountryResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить все опции
     */
    adminSetting_OptionsAll(): Observable<AdminOptionResponse[]> {
        let url_ = this.baseUrl + "/api/AdminSetting/options";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminSetting_OptionsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminSetting_OptionsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminOptionResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminOptionResponse[]>;
        }));
    }

    protected processAdminSetting_OptionsAll(response: HttpResponseBase): Observable<AdminOptionResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminOptionResponse[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить все опции
     */
    adminSetting_HelperAllFull(): Observable<AdminMainHelper[]> {
        let url_ = this.baseUrl + "/api/AdminSetting/helpers/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminSetting_HelperAllFull(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminSetting_HelperAllFull(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminMainHelper[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminMainHelper[]>;
        }));
    }

    protected processAdminSetting_HelperAllFull(response: HttpResponseBase): Observable<AdminMainHelper[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminMainHelper[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Посчитать сумму
     */
    adminSetting_CalculateCount(count: number, discount: number, price: number): Observable<number> {
        let url_ = this.baseUrl + "/api/AdminSetting/calculate/{count}/{discount}/{price}";
        if (count === undefined || count === null)
            throw new Error("The parameter 'count' must be defined.");
        url_ = url_.replace("{count}", encodeURIComponent("" + count));
        if (discount === undefined || discount === null)
            throw new Error("The parameter 'discount' must be defined.");
        url_ = url_.replace("{discount}", encodeURIComponent("" + discount));
        if (price === undefined || price === null)
            throw new Error("The parameter 'price' must be defined.");
        url_ = url_.replace("{price}", encodeURIComponent("" + price));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminSetting_CalculateCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminSetting_CalculateCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processAdminSetting_CalculateCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получение слайдера главной
     */
    adminSlider_GetMainSlider(): Observable<SliderResponse> {
        let url_ = this.baseUrl + "/api/AdminSlider/sliders/home";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminSlider_GetMainSlider(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminSlider_GetMainSlider(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SliderResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SliderResponse>;
        }));
    }

    protected processAdminSlider_GetMainSlider(response: HttpResponseBase): Observable<SliderResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SliderResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Добавление или обновление слайдера
     * @param id (optional)
     * @param isActive (optional)
     * @param title (optional)
     * @param titleSecond (optional)
     * @param url (optional)
     * @param file (optional)
     * @param backgroundColor (optional)
     * @param onlyImage (optional)
     * @param buttonName (optional)
     * @param backgroundImage (optional)
     */
    adminSlider_AddOrUpdate(id: number | undefined, isActive: boolean | undefined, title: string | null | undefined, titleSecond: string | null | undefined, url: string | null | undefined, file: string | null | undefined, backgroundColor: string | null | undefined, onlyImage: boolean | undefined, buttonName: string | null | undefined, backgroundImage: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AdminSlider/slider";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (isActive === null || isActive === undefined)
            throw new Error("The parameter 'isActive' cannot be null.");
        else
            content_.append("IsActive", isActive.toString());
        if (title !== null && title !== undefined)
            content_.append("Title", title.toString());
        if (titleSecond !== null && titleSecond !== undefined)
            content_.append("TitleSecond", titleSecond.toString());
        if (url !== null && url !== undefined)
            content_.append("Url", url.toString());
        if (file !== null && file !== undefined)
            content_.append("File", file.toString());
        if (backgroundColor !== null && backgroundColor !== undefined)
            content_.append("BackgroundColor", backgroundColor.toString());
        if (onlyImage === null || onlyImage === undefined)
            throw new Error("The parameter 'onlyImage' cannot be null.");
        else
            content_.append("OnlyImage", onlyImage.toString());
        if (buttonName !== null && buttonName !== undefined)
            content_.append("ButtonName", buttonName.toString());
        if (backgroundImage !== null && backgroundImage !== undefined)
            content_.append("BackgroundImage", backgroundImage.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminSlider_AddOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminSlider_AddOrUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAdminSlider_AddOrUpdate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить слайд по id
     */
    adminSlider_ItemById(id: number): Observable<SliderItemResponse> {
        let url_ = this.baseUrl + "/api/AdminSlider/slider/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminSlider_ItemById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminSlider_ItemById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SliderItemResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SliderItemResponse>;
        }));
    }

    protected processAdminSlider_ItemById(response: HttpResponseBase): Observable<SliderItemResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SliderItemResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Удалить слайд по id
     */
    adminSlider_RemoveItemById(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AdminSlider/slider/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminSlider_RemoveItemById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminSlider_RemoveItemById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAdminSlider_RemoveItemById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Смена позиции
     * @param firstId (optional)
     * @param secondId (optional) file
     */
    adminSlider_ChangePosition(firstId: number | undefined, secondId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AdminSlider/slider/position";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (firstId === null || firstId === undefined)
            throw new Error("The parameter 'firstId' cannot be null.");
        else
            content_.append("firstId", firstId.toString());
        if (secondId === null || secondId === undefined)
            throw new Error("The parameter 'secondId' cannot be null.");
        else
            content_.append("secondId", secondId.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminSlider_ChangePosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminSlider_ChangePosition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAdminSlider_ChangePosition(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить СТО
     */
    adminSto_Sto(binding: AdminStoRequest): Observable<AdminStoHelper> {
        let url_ = this.baseUrl + "/api/AdminSto/sto";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminSto_Sto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminSto_Sto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminStoHelper>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminStoHelper>;
        }));
    }

    protected processAdminSto_Sto(response: HttpResponseBase): Observable<AdminStoHelper> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminStoHelper;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * обновить СТО по id
     */
    adminSto_StoUpdate(binding: AdminStoUpdateRequest): Observable<AdminStoResponse> {
        let url_ = this.baseUrl + "/api/AdminSto/sto";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminSto_StoUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminSto_StoUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminStoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminStoResponse>;
        }));
    }

    protected processAdminSto_StoUpdate(response: HttpResponseBase): Observable<AdminStoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminStoResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить СТО по id
     */
    adminSto_StoById(id: string): Observable<AdminStoResponse> {
        let url_ = this.baseUrl + "/api/AdminSto/sto/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminSto_StoById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminSto_StoById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminStoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminStoResponse>;
        }));
    }

    protected processAdminSto_StoById(response: HttpResponseBase): Observable<AdminStoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminStoResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить токен для хранилища
     */
    adminStorage_Get(): Observable<string> {
        let url_ = this.baseUrl + "/api/storage/token";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminStorage_Get(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminStorage_Get(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processAdminStorage_Get(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить ОС
     */
    adminStore_Stores(binding: AdminStoreRequest): Observable<AdminStoreHelper> {
        let url_ = this.baseUrl + "/api/AdminStore/stores";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminStore_Stores(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminStore_Stores(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminStoreHelper>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminStoreHelper>;
        }));
    }

    protected processAdminStore_Stores(response: HttpResponseBase): Observable<AdminStoreHelper> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminStoreHelper;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить инфо по id
     */
    adminStore_StoreById(id: number): Observable<AdminStoreHelperResponse> {
        let url_ = this.baseUrl + "/api/AdminStore/stores/item/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminStore_StoreById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminStore_StoreById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminStoreHelperResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminStoreHelperResponse>;
        }));
    }

    protected processAdminStore_StoreById(response: HttpResponseBase): Observable<AdminStoreHelperResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminStoreHelperResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * обновить инфо по id
     * @param id (optional)
     * @param id1C (optional)
     * @param name (optional)
     * @param adress (optional)
     * @param latitude (optional)
     * @param file (optional)
     * @param longtitude (optional)
     * @param description (optional)
     * @param isActive (optional)
     * @param showInFooter (optional)
     * @param type (optional)
     * @param phone (optional)
     * @param cityId (optional)
     * @param frame (optional)
     * @param descriptionHtml (optional)
     */
    adminStore_StoreAddOrUpdate(id: number | undefined, id1C: string | null | undefined, name: string | null | undefined, adress: string | null | undefined, latitude: string | null | undefined, file: string | null | undefined, longtitude: string | null | undefined, description: string | null | undefined, isActive: boolean | undefined, showInFooter: boolean | undefined, type: StoreTypeEnum | undefined, phone: string | null | undefined, cityId: number | null | undefined, frame: string | null | undefined, descriptionHtml: string | null | undefined): Observable<AdminStoreResponse> {
        let url_ = this.baseUrl + "/api/AdminStore/stores/item";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (id1C !== null && id1C !== undefined)
            content_.append("Id1C", id1C.toString());
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (adress !== null && adress !== undefined)
            content_.append("Adress", adress.toString());
        if (latitude !== null && latitude !== undefined)
            content_.append("Latitude", latitude.toString());
        if (file !== null && file !== undefined)
            content_.append("File", file.toString());
        if (longtitude !== null && longtitude !== undefined)
            content_.append("Longtitude", longtitude.toString());
        if (description !== null && description !== undefined)
            content_.append("Description", description.toString());
        if (isActive === null || isActive === undefined)
            throw new Error("The parameter 'isActive' cannot be null.");
        else
            content_.append("IsActive", isActive.toString());
        if (showInFooter === null || showInFooter === undefined)
            throw new Error("The parameter 'showInFooter' cannot be null.");
        else
            content_.append("ShowInFooter", showInFooter.toString());
        if (type === null || type === undefined)
            throw new Error("The parameter 'type' cannot be null.");
        else
            content_.append("Type", type.toString());
        if (phone !== null && phone !== undefined)
            content_.append("Phone", phone.toString());
        if (cityId !== null && cityId !== undefined)
            content_.append("CityId", cityId.toString());
        if (frame !== null && frame !== undefined)
            content_.append("Frame", frame.toString());
        if (descriptionHtml !== null && descriptionHtml !== undefined)
            content_.append("DescriptionHtml", descriptionHtml.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminStore_StoreAddOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminStore_StoreAddOrUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminStoreResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminStoreResponse>;
        }));
    }

    protected processAdminStore_StoreAddOrUpdate(response: HttpResponseBase): Observable<AdminStoreResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminStoreResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Смена позиции
     * @param firstId (optional)
     * @param secondId (optional) file
     */
    adminStore_ChangePosition(firstId: number | undefined, secondId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AdminStore/stores/position";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (firstId === null || firstId === undefined)
            throw new Error("The parameter 'firstId' cannot be null.");
        else
            content_.append("firstId", firstId.toString());
        if (secondId === null || secondId === undefined)
            throw new Error("The parameter 'secondId' cannot be null.");
        else
            content_.append("secondId", secondId.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminStore_ChangePosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminStore_ChangePosition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAdminStore_ChangePosition(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить марки
     */
    adminTecDocCar_Marks(binding: AdminTecDocMarkRequest): Observable<AdminTecDocMarkHelper> {
        let url_ = this.baseUrl + "/api/AdminTecDocCar/tecdoc/cars/vehicles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminTecDocCar_Marks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminTecDocCar_Marks(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminTecDocMarkHelper>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminTecDocMarkHelper>;
        }));
    }

    protected processAdminTecDocCar_Marks(response: HttpResponseBase): Observable<AdminTecDocMarkHelper> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminTecDocMarkHelper;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * обновить или добавить марку по id
     */
    adminTecDocCar_UpdateVehicle(binding: AdminTecDocMarkAddOrUpdate): Observable<AdminTecDocMarkResponse> {
        let url_ = this.baseUrl + "/api/AdminTecDocCar/tecdoc/cars/vehicles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminTecDocCar_UpdateVehicle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminTecDocCar_UpdateVehicle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminTecDocMarkResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminTecDocMarkResponse>;
        }));
    }

    protected processAdminTecDocCar_UpdateVehicle(response: HttpResponseBase): Observable<AdminTecDocMarkResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminTecDocMarkResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить модели
     */
    adminTecDocCar_Models(binding: AdminTecDocModelRequest): Observable<AdminTecDocModelHelper> {
        let url_ = this.baseUrl + "/api/AdminTecDocCar/tecdoc/cars/models";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminTecDocCar_Models(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminTecDocCar_Models(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminTecDocModelHelper>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminTecDocModelHelper>;
        }));
    }

    protected processAdminTecDocCar_Models(response: HttpResponseBase): Observable<AdminTecDocModelHelper> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminTecDocModelHelper;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * обновить или добавить модель по id
     */
    adminTecDocCar_UpdateModel(binding: AdminTecDocModelAddOrUpdate): Observable<AdminTecDocModelResponse> {
        let url_ = this.baseUrl + "/api/AdminTecDocCar/tecdoc/cars/models";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminTecDocCar_UpdateModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminTecDocCar_UpdateModel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminTecDocModelResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminTecDocModelResponse>;
        }));
    }

    protected processAdminTecDocCar_UpdateModel(response: HttpResponseBase): Observable<AdminTecDocModelResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminTecDocModelResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить модификации
     */
    adminTecDocCar_Modifications(binding: AdminTecDocModificationRequest): Observable<AdminTecDocModificationHelper> {
        let url_ = this.baseUrl + "/api/AdminTecDocCar/tecdoc/cars/modifications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminTecDocCar_Modifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminTecDocCar_Modifications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminTecDocModificationHelper>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminTecDocModificationHelper>;
        }));
    }

    protected processAdminTecDocCar_Modifications(response: HttpResponseBase): Observable<AdminTecDocModificationHelper> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminTecDocModificationHelper;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * обновить или добавить модификацию по id
     */
    adminTecDocCar_UpdateModification(binding: AdminTecDocModificationAddOrUpdate): Observable<AdminTecDocModificationResponse> {
        let url_ = this.baseUrl + "/api/AdminTecDocCar/tecdoc/cars/modifications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminTecDocCar_UpdateModification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminTecDocCar_UpdateModification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminTecDocModificationResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminTecDocModificationResponse>;
        }));
    }

    protected processAdminTecDocCar_UpdateModification(response: HttpResponseBase): Observable<AdminTecDocModificationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminTecDocModificationResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить инфо о марке по id
     */
    adminTecDocCar_VehicleById(id: string): Observable<AdminTecDocMarkResponse> {
        let url_ = this.baseUrl + "/api/AdminTecDocCar/tecdoc/cars/vehicles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminTecDocCar_VehicleById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminTecDocCar_VehicleById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminTecDocMarkResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminTecDocMarkResponse>;
        }));
    }

    protected processAdminTecDocCar_VehicleById(response: HttpResponseBase): Observable<AdminTecDocMarkResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminTecDocMarkResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить инфо о модели по id
     */
    adminTecDocCar_ModelById(id: string): Observable<AdminTecDocModelResponse> {
        let url_ = this.baseUrl + "/api/AdminTecDocCar/tecdoc/cars/models/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminTecDocCar_ModelById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminTecDocCar_ModelById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminTecDocModelResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminTecDocModelResponse>;
        }));
    }

    protected processAdminTecDocCar_ModelById(response: HttpResponseBase): Observable<AdminTecDocModelResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminTecDocModelResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить инфо о модификации по id
     */
    adminTecDocCar_ModificationById(id: string): Observable<AdminTecDocModificationResponse> {
        let url_ = this.baseUrl + "/api/AdminTecDocCar/tecdoc/cars/modifications/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminTecDocCar_ModificationById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminTecDocCar_ModificationById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminTecDocModificationResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminTecDocModificationResponse>;
        }));
    }

    protected processAdminTecDocCar_ModificationById(response: HttpResponseBase): Observable<AdminTecDocModificationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminTecDocModificationResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Обновить активность марок
     */
    adminTecDocCar_VehicleUpdateActivity(binding: AdminTecDocUpdateCarActivity1C[]): Observable<void> {
        let url_ = this.baseUrl + "/api/AdminTecDocCar/tecdoc/cars/vehicles/activity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminTecDocCar_VehicleUpdateActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminTecDocCar_VehicleUpdateActivity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAdminTecDocCar_VehicleUpdateActivity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Обновить активность моделей
     */
    adminTecDocCar_ModelUpdateActivity(binding: AdminTecDocUpdateCarActivity1C[]): Observable<void> {
        let url_ = this.baseUrl + "/api/AdminTecDocCar/tecdoc/cars/models/activity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminTecDocCar_ModelUpdateActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminTecDocCar_ModelUpdateActivity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAdminTecDocCar_ModelUpdateActivity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Обновить активность модификаций
     */
    adminTecDocCar_ModificationUpdateActivity(binding: AdminTecDocUpdateCarActivity1C[]): Observable<void> {
        let url_ = this.baseUrl + "/api/AdminTecDocCar/tecdoc/cars/modifications/activity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminTecDocCar_ModificationUpdateActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminTecDocCar_ModificationUpdateActivity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAdminTecDocCar_ModificationUpdateActivity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить ОС
     */
    adminUnit_Units(binding: AdminUnitRequest): Observable<AdminUnitHelper> {
        let url_ = this.baseUrl + "/api/AdminUnit/units";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminUnit_Units(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminUnit_Units(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminUnitHelper>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminUnitHelper>;
        }));
    }

    protected processAdminUnit_Units(response: HttpResponseBase): Observable<AdminUnitHelper> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminUnitHelper;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить инфо по id
     */
    adminUnit_UnitById(id: number): Observable<AdminUnitResponse> {
        let url_ = this.baseUrl + "/api/AdminUnit/units/item/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminUnit_UnitById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminUnit_UnitById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminUnitResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminUnitResponse>;
        }));
    }

    protected processAdminUnit_UnitById(response: HttpResponseBase): Observable<AdminUnitResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminUnitResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * обновить инфо по id
     */
    adminUnit_UnitAddOrUpdate(binding: AdminUnitAddOrUpdate): Observable<AdminUnitResponse> {
        let url_ = this.baseUrl + "/api/AdminUnit/units/item";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminUnit_UnitAddOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminUnit_UnitAddOrUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminUnitResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminUnitResponse>;
        }));
    }

    protected processAdminUnit_UnitAddOrUpdate(response: HttpResponseBase): Observable<AdminUnitResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminUnitResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить пользователей
     */
    adminUser_Users(binding: AdminUserRequest): Observable<AdminUserHelper> {
        let url_ = this.baseUrl + "/api/AdminUser/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminUser_Users(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminUser_Users(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminUserHelper>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminUserHelper>;
        }));
    }

    protected processAdminUser_Users(response: HttpResponseBase): Observable<AdminUserHelper> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminUserHelper;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Получить инфо по id
     */
    adminUser_UserById(id: string): Observable<AdminUserResponse> {
        let url_ = this.baseUrl + "/api/AdminUser/users/item/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminUser_UserById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminUser_UserById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminUserResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminUserResponse>;
        }));
    }

    protected processAdminUser_UserById(response: HttpResponseBase): Observable<AdminUserResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminUserResponse;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Удалить юзера по id
     */
    adminUser_DeleteUserById(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AdminUser/users/item/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminUser_DeleteUserById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminUser_DeleteUserById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAdminUser_DeleteUserById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Обновить или добавить
     */
    adminUser_AddOrUpdateUser(binding: AdminUserAddOrUpdate): Observable<string | null> {
        let url_ = this.baseUrl + "/api/AdminUser/users/items";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(binding);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminUser_AddOrUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminUser_AddOrUpdateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string | null>;
        }));
    }

    protected processAdminUser_AddOrUpdateUser(response: HttpResponseBase): Observable<string | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorMessage;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

/** Успешный ответ авторизации */
export interface LoginResponse {
    /** Access-токен */
    accessToken?: AccessToken | undefined;
    /** Refresh-токен */
    refreshToken?: string | undefined;
}

export interface AccessToken {
    token?: string | undefined;
    expiresIn: number;
}

export interface ProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export interface ErrorMessage {
    message?: string | undefined;
    statusCode: number;
}

export interface LoginRequest {
    login?: string | undefined;
    password?: string | undefined;
    remoteIpAddress?: string | undefined;
    rememberMe: boolean;
}

export interface RestorePasswordRequest {
    login?: string | undefined;
    captcha?: string | undefined;
}

export interface ChangePasswordRequest {
    oldPassword: string;
    password: string;
    passwordAgain: string;
}

export interface RegisterUserRequest {
    /** Электронная почта */
    email: string;
    /** Имя */
    name: string;
    /** Отчество */
    middleName: string;
    /** Фамилия */
    surname: string;
    /** Номер телефона */
    phone: string;
    comment?: string | undefined;
    /** Префикс для телефона (код) */
    prefix: number;
    /** Склад */
    cityId: number;
    /** Страна оператора телефонного номера */
    phoneCountryEnum: PhoneCountryEnum;
    userUtc: number;
}

/** 0 = MDA 1 = UAH 2 = RUS */
export enum PhoneCountryEnum {
    MDA = 0,
    UAH = 1,
    RUS = 2,
}

export interface ExchangeRefreshTokenResponse {
    accessToken?: AccessToken | undefined;
    refreshToken?: string | undefined;
}

export interface ExchangeRefreshTokenRequest {
    accessToken?: string | undefined;
    refreshToken?: string | undefined;
}

export interface UserBalanceRequest {
    id1C?: string | undefined;
    balance: number;
}

export interface RegisterHelperResponse {
    phones?: PhoneCountryResponse[] | undefined;
    countries?: CountryResponse[] | undefined;
}

export interface PhoneCountryResponse {
    id: number;
    value?: string | undefined;
    name?: string | undefined;
    length?: string | undefined;
    code?: string | undefined;
}

export interface CountryResponse {
    id: number;
    id1C?: string | undefined;
    name?: string | undefined;
    isActive: boolean;
    created: Date;
    updated?: Date | undefined;
    cities?: CityResponse[] | undefined;
}

export interface CityResponse {
    id: number;
    id1C?: string | undefined;
    name?: string | undefined;
    isActive: boolean;
    country?: CountryResponse | undefined;
    created: Date;
    updated?: Date | undefined;
}

export interface UserProfileInfoEditResponse {
    fromRequest?: UserProfileInfoEditRequest | undefined;
    newCity?: CityResponse | undefined;
}

export interface UserProfileInfoEditRequest {
    userId: string;
    name?: string | undefined;
    middleName?: string | undefined;
    surname?: string | undefined;
    cityId: number;
    password?: string | undefined;
}

export interface UserAddressResponse {
    id: string;
    address?: string | undefined;
    created: Date;
    updated?: Date | undefined;
}

export interface UserAddressRequest {
    addresses?: string[] | undefined;
    password?: string | undefined;
}

/** Биндинг регистрации */
export interface RegisterUser1CRequest {
    /** Электронная почта */
    email?: string | undefined;
    /** Роль в чате и боковом меню */
    mainRole?: string | undefined;
    /** Имя */
    name?: string | undefined;
    /** Отчество */
    middleName?: string | undefined;
    /** Фамилия */
    surname: string;
    /** Номер телефона */
    phone?: string | undefined;
    /** Склад */
    cityId1C?: string | undefined;
    /** Доступность создания акта сверки */
    isAccountingPermission: boolean;
    /** 0 - ПМР,Молдова 1 - Украина 2 - Роcсия */
    phoneCountryId: number;
    id1C?: string | undefined;
    /** Сдвиг по минутам в UTC */
    userUtc: number;
    /** Логин 1С */
    oldLogin1C?: string | undefined;
    /** 0 - рубль, 1 - доллар */
    userCurrency: UserCurrencyEnum;
    /** 0 - Юридическое лицо, 1 - Физическое лицо */
    userType: UserTypeEnum;
    /** Адреса */
    addresses?: string[] | undefined;
    priceLevelId1C?: string | undefined;
}

/** 0 = PRB 1 = USD */
export enum UserCurrencyEnum {
    PRB = 0,
    USD = 1,
}

/** 0 = LegalEntity 1 = Individual */
export enum UserTypeEnum {
    LegalEntity = 0,
    Individual = 1,
}

export interface UserAccountingHelper {
    userEmail?: string | undefined;
    accounting?: UserAccountingResponse | undefined;
}

export interface UserAccountingResponse {
    id: string;
    dateStart: Date;
    dateStartStr?: string | undefined;
    dateEnd: Date;
    dateEndStr?: string | undefined;
    email?: string | undefined;
    created: Date;
    updated?: Date | undefined;
    createdStr?: string | undefined;
    rangeDateStr?: string | undefined;
    userId: string;
    userId1C?: string | undefined;
}

export interface UserAccountingRequest {
    dateStart: Date;
    dateEnd: Date;
}

export interface UserAccountingResponseHelper {
    isPermission: boolean;
    userAccounting?: UserAccountingResponse[] | undefined;
}

export interface Chat1CResponse {
    message?: ChatResponse | undefined;
    fromUser?: UserProfileResponse | undefined;
    toUser?: UserProfileResponse | undefined;
}

export interface ChatResponse {
    id: string;
    shortName?: string | undefined;
    name?: string | undefined;
    message?: string | undefined;
    role?: string | undefined;
    created: Date;
    createdStr?: string | undefined;
    read?: Date | undefined;
    readStr?: string | undefined;
    isRead: boolean;
    isMine: boolean;
    dialogId: string;
}

export interface UserProfileResponse {
    id: string;
    id1C?: string | undefined;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    middleName?: string | undefined;
    account: number;
    comment?: string | undefined;
    phonePrefix?: string | undefined;
    phoneNumber?: string | undefined;
    created: Date;
    createdStr?: string | undefined;
    updated?: Date | undefined;
    cityId?: number | undefined;
    city?: CityResponse | undefined;
    storeId?: number | undefined;
    store?: StoreResponse | undefined;
    priceLevelId?: number | undefined;
    priceLevel?: PriceLevelResponse | undefined;
    phoneCountryId?: number | undefined;
    phoneCountry?: PhoneCountryResponse | undefined;
    userCurrency?: UserCurrencyResponse | undefined;
    mainRole?: string | undefined;
    userName?: string | undefined;
    oldLogin1C?: string | undefined;
    addresses?: UserAddressResponse[] | undefined;
}

export interface StoreResponse {
    id: number;
    id1C?: string | undefined;
    name?: string | undefined;
    adress?: string | undefined;
    phones?: string[] | undefined;
    latitude?: string | undefined;
    longtitude?: string | undefined;
    description?: string | undefined;
    image?: string | undefined;
    isActive: boolean;
    stringKey?: string | undefined;
    position: number;
    showInFooter: boolean;
    type: StoreTypeEnum;
    created: Date;
    updated?: Date | undefined;
    cityId?: number | undefined;
    city?: CityResponse | undefined;
    isUserStore: boolean;
    frame?: string | undefined;
    descriptionHtml?: string | undefined;
}

/** 0 = Store 1 = Sto 2 = All 3 = ForOrder */
export enum StoreTypeEnum {
    Store = 0,
    Sto = 1,
    All = 2,
    ForOrder = 3,
}

export interface PriceLevelResponse {
    id: number;
    id1C?: string | undefined;
    value: number;
    title?: string | undefined;
    discount: number;
    created: Date;
    updated?: Date | undefined;
}

export interface UserCurrencyResponse {
    title?: string | undefined;
    code?: string | undefined;
    symbol?: string | undefined;
}

export interface UserMailingRequest {
    userIds1C?: string[] | undefined;
    message?: string | undefined;
}

/** 0 = Product 1 = Category */
export enum ImageTypeEnum {
    Product = 0,
    Category = 1,
}

export interface ProductFileDeleteRequest {
    productId1C?: string | undefined;
}

export interface OrderReportRequest {
    orderId: number;
}

export interface Invoice1C {
    id: number;
    userId1C?: string | undefined;
    invoiceSum: number;
    invoiceDateTime: Date;
    packageId?: string | undefined;
    statusSend1C: boolean;
    paymentDateTime: Date;
    offerId: number;
    typeOffer: TypeOffer;
    isTest?: string | undefined;
}

/** 0 = Order 1 = Replenishment */
export enum TypeOffer {
    Order = 0,
    Replenishment = 1,
}

export interface OrderRequest1C {
    id1C?: string | undefined;
    userId1C?: string | undefined;
    paymentType: PaymentTypeEnum;
    deliveryType: DeliveryEnum;
    storeId1C?: string | undefined;
    newStoreId1C?: string | undefined;
    routeTime?: Date | undefined;
    routeId1C?: string | undefined;
    products?: OrderProduct1CRequest[] | undefined;
    address?: string | undefined;
    isPaid: boolean;
    isActive: boolean;
    currency: UserCurrencyEnum;
    dateOfOrder: Date;
    comment?: string | undefined;
    status: OrderStateEnum;
}

/** 0 = InStore 1 = ECash */
export enum PaymentTypeEnum {
    InStore = 0,
    ECash = 1,
}

/** 0 = CustomerPickup 1 = Courier */
export enum DeliveryEnum {
    CustomerPickup = 0,
    Courier = 1,
}

export interface OrderProduct1CRequest {
    count: number;
    productId1C?: string | undefined;
    price: number;
    priceWithoutDiscount: number;
    sum: number;
    sumWithoutDiscount: number;
    storeId: number;
}

/** 0 = Order 1 = Reserved 2 = ToBox 3 = Box 4 = ReadyToGet 5 = Complete 6 = UnReserved 7 = RouteWaiting 8 = RouteComplete 9 = RouteProgress 10 = Waiting */
export enum OrderStateEnum {
    Order = 0,
    Reserved = 1,
    ToBox = 2,
    Box = 3,
    ReadyToGet = 4,
    Complete = 5,
    UnReserved = 6,
    RouteWaiting = 7,
    RouteComplete = 8,
    RouteProgress = 9,
    Waiting = 10,
}

export interface OrderResponse {
    id: number;
    id1C?: string | undefined;
    isPaid: boolean;
    priceProducts: number;
    commentOnOrder?: string | undefined;
    number?: string | undefined;
    currency?: UserCurrencyResponse | undefined;
    user?: UserProfileResponse | undefined;
    created: Date;
    createdStr?: string | undefined;
    userId?: string | undefined;
    paymentType?: PaymentTypeResponse | undefined;
    delivery?: DeliveryResponse | undefined;
    orderHistories?: OrderHistoryResponse[] | undefined;
    actualStatus?: string | undefined;
    orderStateEnum: OrderStateEnum;
    store?: StoreResponse | undefined;
    newStore?: StoreResponse | undefined;
    deliveryInfo?: string | undefined;
    isExpand: boolean;
    isExpandDetail: boolean;
    isExpandHistory: boolean;
    isReject: boolean;
    statuses?: OrderHistoryDayResponse[] | undefined;
    orderProducts?: OrderProductResponse[] | undefined;
    route?: RouteResponse | undefined;
    routeId1C?: string | undefined;
    routeDate?: Date | undefined;
    orderType?: string | undefined;
    phone?: string | undefined;
}

export interface PaymentTypeResponse {
    id: number;
    id1C?: string | undefined;
    name?: string | undefined;
    stringKey?: string | undefined;
    isActive: boolean;
    ePayments?: EPaymentResponse[] | undefined;
}

export interface EPaymentResponse {
    id: number;
    title?: string | undefined;
    logo?: string | undefined;
    stringKey?: string | undefined;
    isActive: boolean;
}

export interface DeliveryResponse {
    id: number;
    name?: string | undefined;
    stringKey?: string | undefined;
    isActive: boolean;
}

export interface OrderHistoryResponse {
    id: string;
    created: Date;
    orderStatus?: string | undefined;
}

export interface OrderHistoryDayResponse {
    day: Date;
    dayStr?: string | undefined;
    statusHistory?: OrderHistoryResponse[] | undefined;
}

export interface OrderProductResponse {
    id: string;
    count: number;
    pricePerItem: number;
    pricePerItemFull: number;
    discount: number;
    priceTotal: number;
    priceDiscount: number;
    created: Date;
    productId: string;
    productId1C?: string | undefined;
    orderProductSnapshotId?: string | undefined;
    orderProductSnapshot?: OrderProductSnapshotResponse | undefined;
    orderId: number;
    iconUrl?: string | undefined;
    stringKey?: string | undefined;
    storeId: number;
    store?: StoreResponse | undefined;
    mainPhoto?: ProductImageResponse | undefined;
}

export interface OrderProductSnapshotResponse {
    id: string;
    id1C?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    articul?: string | undefined;
    stringKey?: string | undefined;
    created: Date;
    unit?: UnitResponse | undefined;
    brand?: BrandResponse | undefined;
}

export interface UnitResponse {
    id: number;
    id1C?: string | undefined;
    name?: string | undefined;
    stringKey?: string | undefined;
    symbol?: string | undefined;
    created: Date;
    updated?: Date | undefined;
}

export interface BrandResponse {
    id: number;
    isActive: boolean;
    isTecDoc: boolean;
    tecDocId: number;
    name?: string | undefined;
    stringKey?: string | undefined;
    description?: string | undefined;
    seoTitle?: string | undefined;
    seoDescription?: string | undefined;
    seoKeywords?: string | undefined;
    shortName?: string | undefined;
}

export interface ProductImageResponse {
    id: string;
    id1C?: string | undefined;
    smallUrl?: string | undefined;
    mediumUrl?: string | undefined;
    originalUrl?: string | undefined;
    isMain: boolean;
    productId: string;
}

export interface RouteResponse {
    id: number;
    id1C?: string | undefined;
    isActive: boolean;
    days?: string | undefined;
    time: Date;
    remainingMinutes: number;
    created: Date;
    updated?: Date | undefined;
    storeId: number;
    storeId1C?: string | undefined;
    store?: StoreResponse | undefined;
    isShow: boolean;
    value?: string | undefined;
    isCheck: boolean;
    sectors?: SectorResponse[] | undefined;
}

export interface SectorResponse {
    id: number;
    id1C?: string | undefined;
    title?: string | undefined;
    type: RouteTypeEnum;
    created: Date;
    updated?: Date | undefined;
    isShow: boolean;
}

/** 0 = Vehicle 1 = Bus */
export enum RouteTypeEnum {
    Vehicle = 0,
    Bus = 1,
}

export interface OrderEmptyId1CRequest {
    orderId: number;
    orderId1C?: string | undefined;
}

export interface QuickOrderRequest {
    phone?: string | undefined;
    comment?: string | undefined;
    basketRequests?: BasketRequest[] | undefined;
}

export interface BasketRequest {
    productId: string;
    storeId: number;
    count: number;
    maxCountInStore: number;
    selected: boolean;
}

/** 0 = Order 1 = QuickOrder 2 = CustomOrder */
export enum OrderNumberType {
    Order = 0,
    QuickOrder = 1,
    CustomOrder = 2,
}

export interface QuickOrderResponse {
    currency?: UserCurrencyResponse | undefined;
    basket?: BasketResponse | undefined;
}

export interface BasketResponse {
    totalCount: number;
    price: number;
    priceWithoutDiscount: number;
    discountValue: number;
    items?: BasketItemResponse[] | undefined;
}

export interface BasketItemResponse {
    id: string;
    count: number;
    productId: string;
    product?: ProductPageResponse | undefined;
    price: number;
    priceDiscount: number;
    priceTotal: number;
    discount: number;
    isDiscount: boolean;
    brand?: BrandResponse | undefined;
    priceWithoutDiscount: number;
    store?: StoreResponse | undefined;
    maxCountInStore: number;
    selected: boolean;
}

export interface ProductPageResponse {
    id: string;
    title?: string | undefined;
    description?: string | undefined;
    fullDescription?: string | undefined;
    isActive: boolean;
    isNew: boolean;
    isDiscount: boolean;
    isBestseller: boolean;
    articul?: string | undefined;
    stringKey?: string | undefined;
    discount: number;
    price: number;
    discountPrice: number;
    seoTitle?: string | undefined;
    seoDescription?: string | undefined;
    seoKeywords?: string | undefined;
    currency?: UserCurrencyResponse | undefined;
    storeProduct?: StoreProductResponse[] | undefined;
    unit?: UnitResponse | undefined;
    priceResponse?: ProductPriceResponse | undefined;
    images?: ProductImageResponse[] | undefined;
    tecDocImages?: string[] | undefined;
    options?: OptionResponse[] | undefined;
    iconUrl?: string | undefined;
    breadcrumbs?: BreadcrumbResponse[] | undefined;
    brand?: BrandResponse | undefined;
    countInfo: boolean;
    analogs?: ProductAnalogResponse[] | undefined;
    oemNumbers?: OemNumber[] | undefined;
    carMarks?: CarTreeResponse[] | undefined;
    additionalParts?: TecDocFullSparePart[] | undefined;
    isWish: boolean;
    wishItemId?: string | undefined;
    url?: string | undefined;
}

export interface StoreProductResponse {
    id: number;
    productId: string;
    count: number;
    countInBasket: number;
    countInBasketReload: number;
    store?: StoreResponse | undefined;
    created: Date;
    updated?: Date | undefined;
    isExpand: boolean;
    delivery?: string | undefined;
    isDelivery: boolean;
    price: number;
}

export interface ProductPriceResponse {
    id: string;
    discountStart?: Date | undefined;
    discountEnd?: Date | undefined;
    rublePrice: number;
    rublePriceDiscount: number;
    dollarPrice: number;
    dollarPriceDiscount: number;
}

export interface OptionResponse {
    id: string;
    name?: string | undefined;
    description?: string | undefined;
    position: number;
    parentId?: string | undefined;
    isDisabled: boolean;
    type: TypeOption;
    values?: OptionValueResponse[] | undefined;
    isActiveNow: boolean;
    isExpand: boolean;
    expandInfo?: string | undefined;
    expandIndex: number;
    expandCount: number;
}

/** 0 = Checkbox 1 = Radio 2 = Select */
export enum TypeOption {
    Checkbox = 0,
    Radio = 1,
    Select = 2,
}

export interface OptionValueResponse {
    id: string;
    value?: string | undefined;
    position: number;
    isCheck: boolean;
    isDisabled: boolean;
    optionId: string;
    productIds?: string[] | undefined;
    dependId?: string | undefined;
    isShow: boolean;
}

export interface BreadcrumbResponse {
    title?: string | undefined;
    url?: string | undefined;
}

export interface ProductAnalogResponse {
    id: string;
    image?: string | undefined;
    title?: string | undefined;
    isActive: boolean;
    isNew: boolean;
    isDiscount: boolean;
    isBestseller: boolean;
    articul?: string | undefined;
    stringKey?: string | undefined;
    discount: number;
    price: number;
    discountPrice: number;
    unit?: UnitResponse | undefined;
    brand?: BrandResponse | undefined;
    countInfo: boolean;
    count: number;
    url?: string | undefined;
    delivery?: string | undefined;
    isDelivery: boolean;
    isMinimalPrice: boolean;
    minimalPrice: number;
    storeCount: number;
}

export interface OemNumber {
    manufacturer?: string | undefined;
    number?: string | undefined;
}

export interface CarTreeResponse {
    id: string;
    name?: string | undefined;
    interval?: string | undefined;
    power?: string | undefined;
    tecDocID: number;
    children?: CarTreeResponse[] | undefined;
}

export interface TecDocFullSparePart {
    partNumber?: string | undefined;
    partName?: string | undefined;
    brandId: number;
    brandName?: string | undefined;
    quantity: number;
}

export interface OrderBasketCounterResponse {
    priceTotal: number;
    count: number;
    orderId: number;
    number?: string | undefined;
    state: OrderStateEnum;
    stateStr?: string | undefined;
}

export interface OrderRequest {
    deliveryId: number;
    paymentTypeId: number;
    newStoreId?: number | undefined;
    storeId?: number | undefined;
    address?: string | undefined;
    comment?: string | undefined;
    basketRequests?: BasketRequest[] | undefined;
    routeId?: number | undefined;
    routeTime?: Date | undefined;
    userDateOffSet: number;
}

export interface OrdersProductsPositionResponse {
    data?: OrdersProductsResponse[] | undefined;
    paginator?: PaginatorResponse | undefined;
}

export interface OrdersProductsResponse {
    number: number;
    dateOfOrder: Date;
    createdStr?: string | undefined;
    brand?: string | undefined;
    articul?: string | undefined;
    currency?: UserCurrencyResponse | undefined;
    title?: string | undefined;
    actualStatus?: string | undefined;
    count: number;
    pricePerItem: number;
    priceTotal: number;
}

export interface PaginatorResponse {
    countStart: number;
    countFinish: number;
    countTotal: number;
    take: number;
    page: number;
    pageCount: number;
    pageSelected?: number[] | undefined;
}

export interface OrdersProductsRequest {
    orderNumber: number;
    articul?: string | undefined;
    createDateFrom?: Date | undefined;
    createDateTo?: Date | undefined;
    actualStatus?: OrderStateEnum | undefined;
    paginator?: PaginatorResponse | undefined;
}

export interface OrdersResponse {
    data?: OrderResponse[] | undefined;
    paginator?: PaginatorResponse | undefined;
}

export interface OrdersRequest {
    orderNumber: number;
    createDateFrom?: Date | undefined;
    createDateTo?: Date | undefined;
    actualStatus?: OrderStateEnum | undefined;
    paginator?: PaginatorResponse | undefined;
}

export interface ApbInvoice {
    ePaymentId: number;
    ivId: number;
    merchant?: string | undefined;
    isTest?: string | undefined;
    password?: string | undefined;
    sum: number;
    currency?: string | undefined;
    description?: string | undefined;
    signatureValue?: string | undefined;
    stateInvoiceSignatureValue?: string | undefined;
}

export interface PayOrderRequest {
    orderId: number;
    ePaymentId: number;
}

export interface GarageCarsResponse {
    totalCount: number;
    userId: string;
    cars?: CarResponse[] | undefined;
}

export interface CarResponse {
    id: string;
    name?: string | undefined;
    tecDocName?: string | undefined;
    vinCode?: string | undefined;
    isMain: boolean;
    tecDocId: number;
    modificationVehicleId: string;
    userModificationVehicleId: string;
}

export interface AddToGarageCarsRequest {
    modificationVehicleId: string;
    name: string;
    vinCode?: string | undefined;
    isMain: boolean;
}

export interface UserStore1CRequest {
    userId1C: string;
    storeId1C: string;
}

export interface ChatHelperResponse {
    messages?: ChatResponse[] | undefined;
    shortName?: string | undefined;
    name?: string | undefined;
    role?: string | undefined;
}

export interface ChatRequest {
    skip: number;
    take: number;
    takeAll: boolean;
}

export interface ChatMessageRequest {
    message?: string | undefined;
}

export interface UserResponse {
    id: string;
    id1C?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    middleName?: string | undefined;
    phoneNumber?: string | undefined;
    account: number;
    comment?: string | undefined;
    phonePrefix?: string | undefined;
    mainRole?: string | undefined;
    oldLogin1C?: string | undefined;
    email?: string | undefined;
    created: Date;
    updated?: Date | undefined;
    city?: CityResponse | undefined;
    priceLevel?: PriceLevelResponse | undefined;
    phoneCountry?: PhoneCountryResponse | undefined;
}

export interface UserEmptyRequest {
    id1C?: string | undefined;
    id: string;
}

export interface UpdateGarageCarRequest {
    userModificationVehicleId: string;
    modificationVehicleId: string;
    name: string;
    vinCode?: string | undefined;
    isMain: boolean;
}

export interface PayReplenishmentRequest {
    amount: number;
}

export interface UserBalanceResponse {
    amount: number;
    history?: ReplenishHistoryResponse[] | undefined;
}

export interface ReplenishHistoryResponse {
    id: number;
    sum: number;
    isPaid: boolean;
    created: Date;
    createdStr?: string | undefined;
}

export interface SuggestResponse {
    productSuggests?: ProductSuggestResponse[] | undefined;
    categoriesSuggests?: CategorySuggestResponse[] | undefined;
}

export interface ProductSuggestResponse {
    name?: string | undefined;
    frequency: number;
}

export interface CategorySuggestResponse {
    name?: string | undefined;
    score: number;
    stringKey?: string | undefined;
    id: string;
}

export interface Exception {
    targetSite?: MethodBase | undefined;
    message: string;
    data: Data[];
    innerException?: Exception | undefined;
    helpLink?: string | undefined;
    source?: string | undefined;
    hResult: number;
    stackTrace?: string | undefined;
}

export interface MemberInfo {
    memberType: MemberTypes;
    name: string;
    declaringType?: string | undefined;
    reflectedType?: string | undefined;
    module: Module;
    customAttributes: CustomAttributeData[];
    isCollectible: boolean;
    metadataToken: number;
}

export interface MethodBase extends MemberInfo {
    attributes: MethodAttributes;
    methodImplementationFlags: MethodImplAttributes;
    callingConvention: CallingConventions;
    isAbstract: boolean;
    isConstructor: boolean;
    isFinal: boolean;
    isHideBySig: boolean;
    isSpecialName: boolean;
    isStatic: boolean;
    isVirtual: boolean;
    isAssembly: boolean;
    isFamily: boolean;
    isFamilyAndAssembly: boolean;
    isFamilyOrAssembly: boolean;
    isPrivate: boolean;
    isPublic: boolean;
    isConstructedGenericMethod: boolean;
    isGenericMethod: boolean;
    isGenericMethodDefinition: boolean;
    containsGenericParameters: boolean;
    methodHandle: RuntimeMethodHandle;
    isSecurityCritical: boolean;
    isSecuritySafeCritical: boolean;
    isSecurityTransparent: boolean;
}

/** 0 = PrivateScope 0 = ReuseSlot 1 = Private 2 = FamANDAssem 3 = Assembly 4 = Family 5 = FamORAssem 6 = Public 7 = MemberAccessMask 8 = UnmanagedExport 16 = Static 32 = Final 64 = Virtual 128 = HideBySig 256 = NewSlot 256 = VtableLayoutMask 512 = CheckAccessOnOverride 1024 = Abstract 2048 = SpecialName 4096 = RTSpecialName 8192 = PinvokeImpl 16384 = HasSecurity 32768 = RequireSecObject 53248 = ReservedMask */
export enum MethodAttributes {
    PrivateScope = 0,
    ReuseSlot = 0,
    Private = 1,
    FamANDAssem = 2,
    Assembly = 3,
    Family = 4,
    FamORAssem = 5,
    Public = 6,
    MemberAccessMask = 7,
    UnmanagedExport = 8,
    Static = 16,
    Final = 32,
    Virtual = 64,
    HideBySig = 128,
    NewSlot = 256,
    VtableLayoutMask = 256,
    CheckAccessOnOverride = 512,
    Abstract = 1024,
    SpecialName = 2048,
    RTSpecialName = 4096,
    PinvokeImpl = 8192,
    HasSecurity = 16384,
    RequireSecObject = 32768,
    ReservedMask = 53248,
}

/** 0 = IL 0 = Managed 1 = Native 2 = OPTIL 3 = CodeTypeMask 3 = Runtime 4 = ManagedMask 4 = Unmanaged 8 = NoInlining 16 = ForwardRef 32 = Synchronized 64 = NoOptimization 128 = PreserveSig 256 = AggressiveInlining 512 = AggressiveOptimization 4096 = InternalCall 65535 = MaxMethodImplVal */
export enum MethodImplAttributes {
    IL = 0,
    Managed = 0,
    Native = 1,
    OPTIL = 2,
    CodeTypeMask = 3,
    Runtime = 3,
    ManagedMask = 4,
    Unmanaged = 4,
    NoInlining = 8,
    ForwardRef = 16,
    Synchronized = 32,
    NoOptimization = 64,
    PreserveSig = 128,
    AggressiveInlining = 256,
    AggressiveOptimization = 512,
    InternalCall = 4096,
    MaxMethodImplVal = 65535,
}

/** 1 = Standard 2 = VarArgs 3 = Any 32 = HasThis 64 = ExplicitThis */
export enum CallingConventions {
    Standard = 1,
    VarArgs = 2,
    Any = 3,
    HasThis = 32,
    ExplicitThis = 64,
}

export interface RuntimeMethodHandle {
    value: IntPtr;
}

export interface IntPtr {
}

/** 1 = Constructor 2 = Event 4 = Field 8 = Method 16 = Property 32 = TypeInfo 64 = Custom 128 = NestedType 191 = All */
export enum MemberTypes {
    Constructor = 1,
    Event = 2,
    Field = 4,
    Method = 8,
    Property = 16,
    TypeInfo = 32,
    Custom = 64,
    NestedType = 128,
    All = 191,
}

export interface Module {
    assembly: Assembly;
    fullyQualifiedName: string;
    name: string;
    mdStreamVersion: number;
    moduleVersionId: string;
    scopeName: string;
    moduleHandle: ModuleHandle;
    customAttributes: CustomAttributeData[];
    metadataToken: number;
}

export interface Assembly {
    definedTypes: TypeInfo[];
    exportedTypes: string[];
    codeBase?: string | undefined;
    entryPoint?: MethodInfo | undefined;
    fullName?: string | undefined;
    imageRuntimeVersion: string;
    isDynamic: boolean;
    location: string;
    reflectionOnly: boolean;
    isCollectible: boolean;
    isFullyTrusted: boolean;
    customAttributes: CustomAttributeData[];
    escapedCodeBase: string;
    manifestModule: Module;
    modules: Module[];
    globalAssemblyCache: boolean;
    hostContext: number;
    securityRuleSet: SecurityRuleSet;
}

export interface Anonymous {
    genericTypeParameters: string[];
    declaredConstructors: ConstructorInfo[];
    declaredEvents: EventInfo[];
    declaredFields: FieldInfo[];
    declaredMembers: MemberInfo[];
    declaredMethods: MethodInfo[];
    declaredNestedTypes: TypeInfo[];
    declaredProperties: PropertyInfo[];
    implementedInterfaces: string[];
}

export interface TypeInfo extends Anonymous {
}

export interface ConstructorInfo extends MethodBase {
    memberType: MemberTypes;
}

export interface EventInfo extends MemberInfo {
    memberType: MemberTypes;
    attributes: EventAttributes;
    isSpecialName: boolean;
    addMethod?: MethodInfo | undefined;
    removeMethod?: MethodInfo | undefined;
    raiseMethod?: MethodInfo | undefined;
    isMulticast: boolean;
    eventHandlerType?: string | undefined;
}

/** 0 = None 512 = SpecialName 1024 = RTSpecialName 1024 = ReservedMask */
export enum EventAttributes {
    None = 0,
    SpecialName = 512,
    RTSpecialName = 1024,
    ReservedMask = 1024,
}

export interface MethodInfo extends MethodBase {
    memberType: MemberTypes;
    returnParameter: ParameterInfo;
    returnType: string;
    returnTypeCustomAttributes: ICustomAttributeProvider;
    genericParameterCount: number;
}

export interface ParameterInfo {
    attributes: ParameterAttributes;
    member: MemberInfo;
    name?: string | undefined;
    parameterType: string;
    position: number;
    isIn: boolean;
    isLcid: boolean;
    isOptional: boolean;
    isOut: boolean;
    isRetval: boolean;
    defaultValue?: any | undefined;
    rawDefaultValue?: any | undefined;
    hasDefaultValue: boolean;
    customAttributes: CustomAttributeData[];
    metadataToken: number;
}

/** 0 = None 1 = In 2 = Out 4 = Lcid 8 = Retval 16 = Optional 4096 = HasDefault 8192 = HasFieldMarshal 16384 = Reserved3 32768 = Reserved4 61440 = ReservedMask */
export enum ParameterAttributes {
    None = 0,
    In = 1,
    Out = 2,
    Lcid = 4,
    Retval = 8,
    Optional = 16,
    HasDefault = 4096,
    HasFieldMarshal = 8192,
    Reserved3 = 16384,
    Reserved4 = 32768,
    ReservedMask = 61440,
}

export interface CustomAttributeData {
    attributeType: string;
    constructor: ConstructorInfo;
    constructorArguments: CustomAttributeTypedArgument[];
    namedArguments: CustomAttributeNamedArgument[];
}

export interface CustomAttributeTypedArgument {
    argumentType: string;
    value?: any | undefined;
}

export interface CustomAttributeNamedArgument {
    argumentType: string;
    memberInfo: MemberInfo;
    typedValue: CustomAttributeTypedArgument;
    memberName: string;
    isField: boolean;
}

export interface ICustomAttributeProvider {
}

export interface FieldInfo extends MemberInfo {
    memberType: MemberTypes;
    attributes: FieldAttributes;
    fieldType: string;
    isInitOnly: boolean;
    isLiteral: boolean;
    isNotSerialized: boolean;
    isPinvokeImpl: boolean;
    isSpecialName: boolean;
    isStatic: boolean;
    isAssembly: boolean;
    isFamily: boolean;
    isFamilyAndAssembly: boolean;
    isFamilyOrAssembly: boolean;
    isPrivate: boolean;
    isPublic: boolean;
    isSecurityCritical: boolean;
    isSecuritySafeCritical: boolean;
    isSecurityTransparent: boolean;
    fieldHandle: RuntimeFieldHandle;
}

/** 0 = PrivateScope 1 = Private 2 = FamANDAssem 3 = Assembly 4 = Family 5 = FamORAssem 6 = Public 7 = FieldAccessMask 16 = Static 32 = InitOnly 64 = Literal 128 = NotSerialized 256 = HasFieldRVA 512 = SpecialName 1024 = RTSpecialName 4096 = HasFieldMarshal 8192 = PinvokeImpl 32768 = HasDefault 38144 = ReservedMask */
export enum FieldAttributes {
    PrivateScope = 0,
    Private = 1,
    FamANDAssem = 2,
    Assembly = 3,
    Family = 4,
    FamORAssem = 5,
    Public = 6,
    FieldAccessMask = 7,
    Static = 16,
    InitOnly = 32,
    Literal = 64,
    NotSerialized = 128,
    HasFieldRVA = 256,
    SpecialName = 512,
    RTSpecialName = 1024,
    HasFieldMarshal = 4096,
    PinvokeImpl = 8192,
    HasDefault = 32768,
    ReservedMask = 38144,
}

export interface RuntimeFieldHandle {
    value: IntPtr;
}

export interface PropertyInfo extends MemberInfo {
    memberType: MemberTypes;
    propertyType: string;
    attributes: PropertyAttributes;
    isSpecialName: boolean;
    canRead: boolean;
    canWrite: boolean;
    getMethod?: MethodInfo | undefined;
    setMethod?: MethodInfo | undefined;
}

/** 0 = None 512 = SpecialName 1024 = RTSpecialName 4096 = HasDefault 8192 = Reserved2 16384 = Reserved3 32768 = Reserved4 62464 = ReservedMask */
export enum PropertyAttributes {
    None = 0,
    SpecialName = 512,
    RTSpecialName = 1024,
    HasDefault = 4096,
    Reserved2 = 8192,
    Reserved3 = 16384,
    Reserved4 = 32768,
    ReservedMask = 62464,
}

/** 0 = None 1 = Level1 2 = Level2 */
export enum SecurityRuleSet {
    None = 0,
    Level1 = 1,
    Level2 = 2,
}

export interface ModuleHandle {
    mdStreamVersion: number;
}

export interface FullSearchResponse {
    productPaginatorResponse?: PaginatorResponse | undefined;
    searchProductResponse?: SearchProductResponse | undefined;
    searchBrandResponse?: SearchBrandResponse[] | undefined;
    currency?: UserCurrencyResponse | undefined;
    brandList?: TecDocBrandResponse[] | undefined;
    searchProductResponses?: SearchProductResponse[] | undefined;
}

export interface SearchProductResponse {
    id: string;
    title?: string | undefined;
    description?: string | undefined;
    brandName?: string | undefined;
    tecDocBrandId: number;
    created: Date;
    quantity: number;
    quantityUnit?: string | undefined;
    price: number;
    priceDiscount: number;
    stringKey?: string | undefined;
    isActive: boolean;
    isNew: boolean;
    isDiscount: boolean;
    isBestseller: boolean;
    articul?: string | undefined;
    images?: string[] | undefined;
    isTecDocOnly: boolean;
    tecDocId: number;
    discount: number;
    sparePartSpecifications?: SparePartSpecification[] | undefined;
    productAnalogs?: SearchProductResponse[] | undefined;
    storeCountResponses?: SearchProductStoreCountResponse[] | undefined;
    countInStore: number;
    image?: string | undefined;
    tecDocImage?: string | undefined;
    isDelivery: boolean;
    isMinimalPrice: boolean;
    minimalPrice: number;
}

export interface SparePartSpecification {
    id: number;
    description?: string | undefined;
    title?: string | undefined;
    value?: string | undefined;
}

export interface SearchProductStoreCountResponse {
    id: number;
    title?: string | undefined;
    count: number;
    delivery?: string | undefined;
    isDelivery: boolean;
    countInBasket: number;
    countInBasketReload: number;
    price: number;
}

export interface SearchBrandResponse {
    productName?: string | undefined;
    productArticul?: string | undefined;
    brandId: number;
    brandName?: string | undefined;
}

export interface TecDocBrandResponse {
    id: number;
    shortName?: string | undefined;
}

export interface SearchRequest {
    query?: string | undefined;
    tecDocBrands?: number[] | undefined;
    selectedBrand?: string | undefined;
    tecDocBrandId?: number | undefined;
    shortName?: string | undefined;
    onlyCount: boolean;
    take?: number | undefined;
    page?: number | undefined;
    order: OrderTypeEnum;
}

/** 0 = ByAvailability 1 = ToExpensive 2 = FromExpensive 3 = ByTitleAz 4 = ByTitleZa 5 = ByBrandAz 6 = ByBrandZa */
export enum OrderTypeEnum {
    ByAvailability = 0,
    ToExpensive = 1,
    FromExpensive = 2,
    ByTitleAz = 3,
    ByTitleZa = 4,
    ByBrandAz = 5,
    ByBrandZa = 6,
}

export interface TestBinding {
    access_token?: string | undefined;
    user_name?: string | undefined;
}

export interface NotifyBroadcastMessageBinding {
    type?: string | undefined;
    payload?: string | undefined;
}

export interface ArticleResponse {
    id: number;
    stringKey?: string | undefined;
    title?: string | undefined;
    annonse?: string | undefined;
    description?: string | undefined;
    metaTitle?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    isActive: boolean;
    type: ArticleEnum;
    isMain: boolean;
    image?: string | undefined;
    categoryTitle?: string | undefined;
    created: Date;
    createdStr?: string | undefined;
    updated?: Date | undefined;
    typeStr?: string | undefined;
    categoryId: number;
    prevArticle?: ArticleLinkResponse | undefined;
    nextArticle?: ArticleLinkResponse | undefined;
}

/** 0 = Article 1 = Sale */
export enum ArticleEnum {
    Article = 0,
    Sale = 1,
}

export interface ArticleLinkResponse {
    title?: string | undefined;
    stringKey?: string | undefined;
}

export interface BlogRequest {
    take: number;
    skip: number;
    isActive: boolean;
    all: boolean;
}

export interface BasketCityResponse {
    cityTitle?: string | undefined;
    currency?: UserCurrencyResponse | undefined;
    store?: StoreResponse | undefined;
    cityBasket?: BasketResponse | undefined;
    address?: string | undefined;
    isExpand: boolean;
}

export interface BasketCountResponse {
    count: number;
    priceTotal: number;
    symbol?: string | undefined;
    store?: string | undefined;
}

export interface BrandRequest {
    id1C?: string | undefined;
    shortName?: string | undefined;
    isActive: boolean;
    name?: string | undefined;
    description?: string | undefined;
    seoTitle?: string | undefined;
    seoDescription?: string | undefined;
    seoKeywords?: string | undefined;
    countryId1C?: string | undefined;
}

export interface CategoryResponse {
    id: string;
    id1C?: string | undefined;
    parentId1C?: string | undefined;
    title?: string | undefined;
    stringKey?: string | undefined;
    showCategory: boolean;
    child?: CategoryResponse[] | undefined;
    icon?: string | undefined;
    image?: string | undefined;
    seoTitle?: string | undefined;
    seoDescription?: string | undefined;
    seoKeywords?: string | undefined;
    isMain: boolean;
    isSale: boolean;
    isDropDownMenu: boolean;
    breadcrumbs?: BreadcrumbResponse[] | undefined;
    isHasChild: boolean;
}

export interface SaleProductRequest {
    paginator?: PaginatorResponse | undefined;
    filter?: FilterRequest | undefined;
    currency?: UserCurrencyResponse | undefined;
    options?: OptionHelperResponse | undefined;
    optMarkId?: string | undefined;
    optModelId?: string | undefined;
}

export interface FilterRequest {
    isReset: boolean;
    minPrice: number;
    maxPrice: number;
    currentMinPrice: number;
    currentMaxPrice: number;
    orderBy: OrderTypeEnum;
    checkedOptionValues?: CheckedOptionValue[] | undefined;
}

export interface CheckedOptionValue {
    optionId: string;
    optionValueId: string;
    value?: string | undefined;
    productIds?: string[] | undefined;
}

export interface OptionHelperResponse {
    oldOptionByPostions?: OptionByPostion[] | undefined;
    checkbox?: OptionResponse[] | undefined;
    radio?: OptionResponse[] | undefined;
    select?: SelectOptionHelper[] | undefined;
}

export interface OptionByPostion {
    position: number;
    option?: OptionResponse | undefined;
    type: TypeOption;
    value?: string | undefined;
    valueArray?: string[] | undefined;
    title?: string | undefined;
    isShow: boolean;
}

export interface SelectOptionHelper {
    option?: OptionResponse | undefined;
    value?: string | undefined;
    valueArray?: string[] | undefined;
    title?: string | undefined;
}

export interface CategoryRequest {
    id1C: string;
    title?: string | undefined;
    description?: string | undefined;
    fullDescription?: string | undefined;
    seoTitle?: string | undefined;
    seoDescription?: string | undefined;
    seoKeywords?: string | undefined;
    isActive: boolean;
    isSetNew: boolean;
    isSetDiscount: boolean;
    isSetBestseller: boolean;
    discount: number;
    parentId1C?: string | undefined;
    position: number;
    isSale: boolean;
}

export interface CityRequest {
    id1C?: string | undefined;
    name?: string | undefined;
    isActive: boolean;
    countryId1C?: string | undefined;
    position: number;
}

export interface ContactUsRequest {
    emailPhone?: string | undefined;
    name?: string | undefined;
    comment?: string | undefined;
    captcha?: string | undefined;
}

export interface AdminContactUsResponse {
    id: string;
    contact?: string | undefined;
    name?: string | undefined;
    message?: string | undefined;
    managerComment?: string | undefined;
    state: ContactUsStateEnum;
    stateStr?: string | undefined;
    created: Date;
    updated?: Date | undefined;
    createdStr?: string | undefined;
    updatedStr?: string | undefined;
    userProcessedId?: string | undefined;
    user?: UserProfileResponse | undefined;
}

/** 0 = New 1 = InProgress 2 = Complete 3 = Reject 4 = All */
export enum ContactUsStateEnum {
    New = 0,
    InProgress = 1,
    Complete = 2,
    Reject = 3,
    All = 4,
}

export interface ContactUsStateRequest {
    state: ContactUsStateEnum;
    query?: string | undefined;
}

export interface ContactUsUpdateRequest {
    id: string;
    managerComment?: string | undefined;
    state: ContactUsStateEnum;
}

export interface CountryRequest {
    id1C: string;
    name?: string | undefined;
    isActive: boolean;
}

export interface DownloadInfoResponse {
    id: string;
    title?: string | undefined;
    stringKey?: string | undefined;
    image?: string | undefined;
    created: Date;
    updated?: Date | undefined;
    isActive: boolean;
    items?: DownloadInfoItemResponse[] | undefined;
}

export interface DownloadInfoItemResponse {
    id: string;
    title?: string | undefined;
    image?: string | undefined;
    file?: string | undefined;
    stringKey?: string | undefined;
    created: Date;
    updated?: Date | undefined;
    isActive: boolean;
    fileType?: string | undefined;
    fileSize: number;
}

export interface DownloadInfoRequest {
    id: string;
    title?: string | undefined;
    isActive: boolean;
}

export interface DownloadInfoItemRequest {
    id: string;
    infoId: string;
    title?: string | undefined;
    isActive: boolean;
}

export interface SectorRequest {
    id1C: string;
    title?: string | undefined;
    type: RouteTypeEnum;
}

export interface RouteRequest {
    id1C: string;
    isActive: boolean;
    days?: string | undefined;
    time: Date;
    remainingMinutes: number;
    storeId1C?: string | undefined;
    title?: string | undefined;
}

export interface UserSectorRequest {
    userId1C: string;
    sectorId1C: string;
}

export interface RouteSectorRequest {
    routeId1C: string;
    sectorId1C: string;
}

export interface MenuSectionResponse {
    headerTop?: MenuResponse[] | undefined;
    header?: MenuResponse[] | undefined;
    footer?: MenuResponse[] | undefined;
    sliderDown?: MenuResponse[] | undefined;
    profileMenu?: MenuResponse[] | undefined;
}

export interface MenuResponse {
    id: number;
    name?: string | undefined;
    stringKey?: string | undefined;
    url?: string | undefined;
    isActive: boolean;
    type: MenuEnum;
    position: number;
    items?: MenuItemResponse[] | undefined;
    count: number;
    page?: PageResponse | undefined;
}

/** 0 = HeaderTop 1 = Header 2 = Footer 3 = SliderDown 4 = Profile */
export enum MenuEnum {
    HeaderTop = 0,
    Header = 1,
    Footer = 2,
    SliderDown = 3,
    Profile = 4,
}

export interface MenuItemResponse {
    id: number;
    name?: string | undefined;
    stringKey?: string | undefined;
    url?: string | undefined;
    isActive: boolean;
    position: number;
    count: number;
    page?: PageResponse | undefined;
}

export interface PageResponse {
    id: number;
    stringKey?: string | undefined;
    name?: string | undefined;
    content?: string | undefined;
    metaTitle?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    url?: string | undefined;
}

export interface OptionRequest {
    id1C: string;
    name?: string | undefined;
    description?: string | undefined;
    isActive: boolean;
    parentId1C?: string | undefined;
    type: TypeOption;
    position: number;
}

export interface OptionValueRequest {
    id1C: string;
    value?: string | undefined;
    isActive: boolean;
    optionId1C: string;
    dependId1C?: string | undefined;
    position: number;
}

export interface PartnerResponse {
    id: number;
    name?: string | undefined;
    description?: string | undefined;
    image?: string | undefined;
    url?: string | undefined;
    country?: string | undefined;
}

export interface PriceLevelRequest {
    id1C: string;
    title?: string | undefined;
}

export interface PriceLevelBrandRequest {
    priceLevelId1C: string;
    brandId1C: string;
    discount: number;
}

export interface ProductAnalogHelper {
    analogs?: SearchProductResponse[] | undefined;
    paginator?: PaginatorResponse | undefined;
    querry?: string | undefined;
    tecDocBrandId?: number | undefined;
    productId: string;
}

export interface CarApplicabilityMarksResponse {
    id: number;
    name?: string | undefined;
    models?: CarApplicabilityModelsResponse[] | undefined;
}

export interface CarApplicabilityModelsResponse {
    id: number;
    name?: string | undefined;
    modifications?: CarApplicabilityModificationsResponse[] | undefined;
}

export interface CarApplicabilityModificationsResponse {
    tecDocID: number;
    name?: string | undefined;
}

export interface ProductRequest {
    id1C: string;
    title?: string | undefined;
    description?: string | undefined;
    fullDescription?: string | undefined;
    isShowMain: boolean;
    isActive: boolean;
    isNew: boolean;
    isDiscount: boolean;
    isBestseller: boolean;
    articul?: string | undefined;
    seoTitle?: string | undefined;
    seoDescription?: string | undefined;
    seoKeywords?: string | undefined;
    brandId1C?: string | undefined;
    crossNumber?: string | undefined;
    productOptionValueIds?: string[] | undefined;
    categoryId1C?: string[] | undefined;
    productPrice?: CurrencyPriceRequest | undefined;
    storeProductCount?: StoreProductCountRequest[] | undefined;
    unitId1C?: string | undefined;
}

export interface CurrencyPriceRequest {
    discountStart?: Date | undefined;
    discountEnd?: Date | undefined;
    rublePrice: number;
    rublePriceDiscount: number;
    dollarPrice: number;
    dollarPriceDiscount: number;
}

export interface StoreProductCountRequest {
    storeId1C?: string | undefined;
    count: number;
    delivery?: string | undefined;
}

export interface ProductSQLSource {
    id1C?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    fullDescription?: string | undefined;
    isShowMain: boolean;
    isActive: boolean;
    isNew: boolean;
    isDiscount: boolean;
    isBestseller: boolean;
    articul?: string | undefined;
    seoTitle?: string | undefined;
    seoDescription?: string | undefined;
    seoKeywords?: string | undefined;
    brandId1C?: string | undefined;
    crossNumber?: string | undefined;
    productOptionValueIds?: string[] | undefined;
    categoryId1C?: string[] | undefined;
    productPrice?: ProductPriceSQLSource | undefined;
    storeProductCount?: StoreProductCountSQLSource[] | undefined;
    unitId1C?: string | undefined;
}

export interface ProductPriceSQLSource {
    discountStart?: Date | undefined;
    discountEnd?: Date | undefined;
    rublePrice: number;
    rublePriceDiscount: number;
    dollarPrice: number;
    dollarPriceDiscount: number;
}

export interface StoreProductCountSQLSource {
    storeId1C?: string | undefined;
    count: number;
    dollarPrice: number;
    rublePrice: number;
    delivery?: string | undefined;
}

export interface ProductPaginatorResponse {
    paginator?: PaginatorResponse | undefined;
    products?: CategoryProductFullResponse[] | undefined;
    filter?: FilterRequest | undefined;
    currency?: UserCurrencyResponse | undefined;
    options?: OptionHelperResponse | undefined;
    optionByPostions?: OptionByPostion[] | undefined;
    isEmpty: boolean;
}

export interface CategoryProductFullResponse {
    id: string;
    title?: string | undefined;
    description?: string | undefined;
    fullDescription?: string | undefined;
    isActive: boolean;
    isNew: boolean;
    isDiscount: boolean;
    isDiscounLabel: boolean;
    isBestseller: boolean;
    articul?: string | undefined;
    stringKey?: string | undefined;
    discount: number;
    price: number;
    discountPrice: number;
    images?: ProductImageResponse[] | undefined;
    currency?: string | undefined;
    brand?: BrandResponse | undefined;
    countInfo: boolean;
    isWish: boolean;
    wishItemId?: string | undefined;
    delivery?: string | undefined;
    isDelivery: boolean;
}

export interface CategoryProductRequest {
    categoryId?: string | undefined;
    paginator?: PaginatorResponse | undefined;
    filter?: FilterRequest | undefined;
    currency?: UserCurrencyResponse | undefined;
    options?: OptionHelperResponse | undefined;
    optionByPostions?: OptionByPostion[] | undefined;
    brands?: SaleBrandResponse[] | undefined;
    markId?: string | undefined;
    modelId?: string | undefined;
    valuesFromRoute?: string[] | undefined;
}

export interface SaleBrandResponse {
    name?: string | undefined;
    id: number;
    isChecked: boolean;
}

export interface ProductSalePaginatorResponse {
    paginator?: PaginatorResponse | undefined;
    products?: SaleProductResponse[] | undefined;
    filter?: FilterRequest | undefined;
    currency?: UserCurrencyResponse | undefined;
    options?: OptionHelperResponse | undefined;
    optionByPostions?: OptionByPostion[] | undefined;
    isEmpty: boolean;
    brands?: SaleBrandResponse[] | undefined;
    markId?: string | undefined;
    modelId?: string | undefined;
}

export interface SaleProductResponse {
    id: string;
    stringKey?: string | undefined;
    articul?: string | undefined;
    brandName?: string | undefined;
    title?: string | undefined;
    count: number;
    unit?: string | undefined;
    price: number;
    priceDiscount: number;
    label?: string | undefined;
}

export interface PageProductHomeSectionsResponse {
    section?: ProductHomePageResponse[] | undefined;
}

export interface ProductHomePageResponse {
    title?: string | undefined;
    products?: CategoryProductFullResponse[] | undefined;
    clientProducts?: CategoryProductFullResponse[] | undefined;
}

export interface ProductCarModelRequest {
    productIdC1?: string | undefined;
    modelId?: number[] | undefined;
}

export interface SocialNetworkResponse {
    id: number;
    name?: string | undefined;
    url?: string | undefined;
    isActive: boolean;
    image?: string | undefined;
}

export interface FooterResponse {
    footerInfo?: string | undefined;
    copyright?: string | undefined;
    tireCalculator?: string | undefined;
    stores?: StoreFooterResponse[] | undefined;
}

export interface StoreFooterResponse {
    title?: string | undefined;
    address?: string | undefined;
    phones?: string[] | undefined;
}

export interface SettingsResponse {
    tecDocActivity?: SettingResponse | undefined;
    emailActive?: SettingResponse | undefined;
    footerInfo?: SettingResponse | undefined;
    copyright?: SettingResponse | undefined;
    eCash?: SettingResponse | undefined;
    tireCalculator?: SettingResponse | undefined;
    smsActive?: SettingResponse | undefined;
    email?: SettingResponse | undefined;
    emailPass?: SettingResponse | undefined;
    aplBrand?: SettingResponse | undefined;
    aplModel?: SettingResponse | undefined;
    topLabel?: SettingResponse | undefined;
    newLabel?: SettingResponse | undefined;
    socials?: SocialNetworkResponse[] | undefined;
}

export interface SettingResponse {
    id: number;
    value?: string | undefined;
    valueBool: boolean;
    valueInt: number;
    type: SettingTypeEnum;
    keyString: SettingKeyStringEnum;
    description?: string | undefined;
}

/** 0 = Boolean 1 = String 2 = Int */
export enum SettingTypeEnum {
    Boolean = 0,
    String = 1,
    Int = 2,
}

/** 0 = TecDocActivity 1 = EmailActive 2 = FooterInfo 3 = Copyright 4 = ECash 5 = TireCalculator 6 = SmsActive 7 = Email 8 = EmailPass 9 = AplBrand 10 = AplModel 11 = TopLabel 12 = NewLabel */
export enum SettingKeyStringEnum {
    TecDocActivity = 0,
    EmailActive = 1,
    FooterInfo = 2,
    Copyright = 3,
    ECash = 4,
    TireCalculator = 5,
    SmsActive = 6,
    Email = 7,
    EmailPass = 8,
    AplBrand = 9,
    AplModel = 10,
    TopLabel = 11,
    NewLabel = 12,
}

export interface SettingActiveResponse {
    tecDoc: boolean;
    eCash: boolean;
    smsActive: boolean;
}

export interface SliderResponse {
    id: number;
    isActive: boolean;
    title?: string | undefined;
    type: SliderEnum;
    items?: SliderItemResponse[] | undefined;
}

/** 0 = Main */
export enum SliderEnum {
    Main = 0,
}

export interface SliderItemResponse {
    id: number;
    isActive: boolean;
    title?: string | undefined;
    url?: string | undefined;
    position: number;
    image?: string | undefined;
    backgroundColor?: string | undefined;
    titleSecond?: string | undefined;
    created: Date;
    updated?: Date | undefined;
    onlyImage: boolean;
    buttonName?: string | undefined;
    backgroundImage?: string | undefined;
}

export interface StoRequest {
    time?: string | undefined;
    date: Date;
    carNumber?: string | undefined;
    carYear?: string | undefined;
    carBrand?: string | undefined;
    carBrandId: string;
    carModel?: string | undefined;
    carModelId: string;
    carVehicle?: string | undefined;
    carVehicleId: string;
    name?: string | undefined;
    phone?: string | undefined;
    comment?: string | undefined;
    prefix?: string | undefined;
    services?: ServiceRequest[] | undefined;
    userId?: string | undefined;
}

export interface ServiceRequest {
    isCheck: boolean;
    serviceId: number;
    serviceName?: string | undefined;
}

export interface AdminStoResponse {
    id: string;
    name?: string | undefined;
    phone?: string | undefined;
    time?: string | undefined;
    date: Date;
    dateStr?: string | undefined;
    carYear?: string | undefined;
    carBrand?: string | undefined;
    carModel?: string | undefined;
    carEngine?: string | undefined;
    carBrandId: string;
    carModelId: string;
    carEngineId: string;
    carNumber?: string | undefined;
    commentUser?: string | undefined;
    commentManager?: string | undefined;
    status: StoStatusEnum;
    statusStr?: string | undefined;
    rejectReason?: string | undefined;
    created: Date;
    createdStr?: string | undefined;
    updated?: Date | undefined;
    updatedStr?: string | undefined;
    userId?: string | undefined;
    user?: UserProfileResponse | undefined;
    services?: AdminStoServiceResponse[] | undefined;
}

/** 0 = New 1 = InProgress 2 = Done 3 = RejectManager 4 = RejectClient */
export enum StoStatusEnum {
    New = 0,
    InProgress = 1,
    Done = 2,
    RejectManager = 3,
    RejectClient = 4,
}

export interface AdminStoServiceResponse {
    id: number;
    name?: string | undefined;
    isCheck: boolean;
}

export interface StoFilterRequest {
    state: StoStatusEnum;
    query?: string | undefined;
}

export interface StoSubUpdateRequest {
    id: string;
    name?: string | undefined;
    phone?: string | undefined;
    time?: string | undefined;
    date: Date;
    carNumber?: string | undefined;
    commentUser?: string | undefined;
    commentManager?: string | undefined;
    status: StoStatusEnum;
    rejectReason?: string | undefined;
    serviceIds?: number[] | undefined;
}

export interface StoSubStatusUpdateRequest {
    id: string;
    status: StoStatusEnum;
}

export interface StoreServiceResponse {
    id: number;
    name?: string | undefined;
    isActive: boolean;
    annonse?: string | undefined;
    description?: string | undefined;
    metaTitile?: string | undefined;
    metaDescription?: string | undefined;
    metaKeywords?: string | undefined;
    image?: string | undefined;
    icon?: string | undefined;
    position: number;
}

export interface StoreRequest {
    id1C: string;
    name?: string | undefined;
    phone?: string | undefined;
    adress?: string | undefined;
    latitude?: string | undefined;
    longtitude?: string | undefined;
    description: string;
    isActive: boolean;
    stringKey?: string | undefined;
    position: number;
    showInFooter: boolean;
    type: StoreTypeEnum;
    cityId1C: string;
}

export interface UnitRequest {
    id1C: string;
    name?: string | undefined;
    symbol?: string | undefined;
}

export interface WishListResponse {
    id: string;
    userId?: string | undefined;
    currency?: UserCurrencyResponse | undefined;
    items?: WishListItemResponse[] | undefined;
    price: number;
}

export interface WishListItemResponse {
    id: string;
    productId: string;
    selected: boolean;
    product?: ProductPageResponse | undefined;
}

export interface CarMarksResponse {
    id: string;
    name?: string | undefined;
    models?: CarModelsResponse[] | undefined;
}

export interface CarModelsResponse {
    id: string;
    name?: string | undefined;
    interval?: string | undefined;
    modifications?: CarModificationsResponse[] | undefined;
}

export interface CarModificationsResponse {
    id: string;
    name?: string | undefined;
    fullName?: string | undefined;
    interval?: string | undefined;
    tecDocID: number;
    engineCodes?: string | undefined;
    powerKw?: string | undefined;
    powerPs?: string | undefined;
    capacityCcm?: string | undefined;
    bodyType?: string | undefined;
    fuelType?: string | undefined;
}

export interface CarDetailResponse {
    name?: string | undefined;
    modificationId: number;
    modelId: number;
    markId: number;
    yearInterval?: string | undefined;
    engineCodes?: string | undefined;
    driveType?: string | undefined;
    powerKw?: string | undefined;
    powerPs?: string | undefined;
    kbaNumber?: string | undefined;
    capacityCcm?: string | undefined;
    capacityL?: string | undefined;
    numberOfCylinders?: string | undefined;
    numberOfValves?: string | undefined;
    bodyType?: string | undefined;
    fuelType?: string | undefined;
}

export interface FullTecDocResponse {
    pageCount: number;
    countTotal: number;
    productPaginatorResponse?: PaginatorResponse | undefined;
    searchProductResponses?: SearchProductResponse[] | undefined;
    currency?: UserCurrencyResponse | undefined;
    brandList?: TecDocBrandResponse[] | undefined;
}

export interface SparePartRequest {
    tecDocCategoryId: number;
    tecDocModificationId: number;
    tecDocBrands?: number[] | undefined;
    onlyCount: boolean;
    take?: number | undefined;
    page?: number | undefined;
    order: OrderTypeEnum;
}

export interface TecDocCategoryFullResponse {
    categories?: TecDocCategoryResponse[] | undefined;
    carDetailResponse?: CarDetailResponse | undefined;
}

export interface TecDocCategoryResponse {
    id: number;
    text?: string | undefined;
    parentid: number;
    selected: boolean;
    children?: TecDocCategoryResponse[] | undefined;
}

export interface AdminBrandHelper {
    brands?: AdminBrandResponse[] | undefined;
    paginator?: PaginatorResponse | undefined;
    isEmpty: boolean;
}

export interface AdminBrandResponse {
    id: number;
    id1C?: string | undefined;
    shortName?: string | undefined;
    isActive: boolean;
    name?: string | undefined;
    stringKey?: string | undefined;
    description?: string | undefined;
    logo?: string | undefined;
    seoTitle?: string | undefined;
    seoDescription?: string | undefined;
    seoKeywords?: string | undefined;
    tecDocBrandId?: number | undefined;
    isTecDoc: boolean;
    created: Date;
    updated?: Date | undefined;
    countryId?: number | undefined;
    countryStr?: string | undefined;
}

export interface AdminBrandRequest {
    pageFilter?: AdminPageFilterRequest | undefined;
}

export interface AdminPageFilterRequest {
    page: number;
    take: number;
    query?: string | undefined;
    orderByColumn?: string | undefined;
    orderBy?: string | undefined;
}

export interface AdminBrandHelperResponse {
    brand?: AdminBrandResponse | undefined;
    countries?: AdminCountryResponse[] | undefined;
}

export interface AdminCountryResponse {
    id: number;
    id1C?: string | undefined;
    name?: string | undefined;
    isActive: boolean;
    created: Date;
    updated?: Date | undefined;
    cities?: AdminCityResponse[] | undefined;
}

export interface AdminCityResponse {
    id: number;
    id1C?: string | undefined;
    name?: string | undefined;
    isActive: boolean;
    created: Date;
    updated?: Date | undefined;
    country?: string | undefined;
    countryId: number;
    position: number;
}

export interface AdminBrandAddOrUpdate {
    id: number;
    id1C?: string | undefined;
    shortName?: string | undefined;
    isActive: boolean;
    name?: string | undefined;
    description?: string | undefined;
    seoTitle?: string | undefined;
    seoDescription?: string | undefined;
    seoKeywords?: string | undefined;
    tecDocBrandId?: number | undefined;
    isTecDoc: boolean;
    countryId?: number | undefined;
}

export interface AdminTecDocBrandBlackListResponse {
    id: string;
    tecDocBrandId: number;
    shortName?: string | undefined;
    created: Date;
}

export interface AdminTecDocBrandBlackListAddOrUpdate {
    tecDocBrandIds?: number[] | undefined;
    blackListIds?: string[] | undefined;
}

export interface AdminCategoryHelper {
    categories?: AdminCategoryResponse[] | undefined;
    paginator?: PaginatorResponse | undefined;
    isEmpty: boolean;
}

export interface AdminCategoryResponse {
    id: string;
    id1C?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    fullDescription?: string | undefined;
    imageIcon?: string | undefined;
    image?: string | undefined;
    stringKey?: string | undefined;
    seoTitle?: string | undefined;
    seoDescription?: string | undefined;
    seoKeywords?: string | undefined;
    position: number;
    created: Date;
    updated?: Date | undefined;
    parentId?: string | undefined;
    parentId1C?: string | undefined;
    jsonParents?: string | undefined;
    parents?: AdminCategoryParentHelper[] | undefined;
    isSale: boolean;
    isActive: boolean;
}

export interface AdminCategoryParentHelper {
    categoryId: string;
    categoryName?: string | undefined;
}

export interface AdminCategoryRequest {
    pageFilter?: AdminPageFilterRequest | undefined;
}

export interface AdminShortChatHelper {
    users?: AdminShortChatResponse[] | undefined;
    paginator?: PaginatorResponse | undefined;
    isEmpty: boolean;
}

export interface AdminShortChatResponse {
    userId: string;
    date?: Date | undefined;
    lastMessage?: string | undefined;
    userName?: string | undefined;
    icon?: string | undefined;
    count: number;
}

export interface AdminShortChatRequest {
    pageFilter?: AdminPageFilterRequest | undefined;
}

export interface AdminChatInfoHelper {
    messages?: ChatResponse[] | undefined;
    isEmpty: boolean;
    take: number;
    skip: number;
    user?: AdminUserProfileResponse | undefined;
}

export interface AdminUserProfileResponse {
    id: string;
    id1C?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    middleName?: string | undefined;
    phoneNumber?: string | undefined;
    account: number;
    comment?: string | undefined;
    phonePrefix?: string | undefined;
    userName?: string | undefined;
    icon?: string | undefined;
    store?: StoreResponse | undefined;
    created: Date;
    updated?: Date | undefined;
}

export interface AdminChatInfoRequest {
    take: number;
    skip: number;
    userId: string;
}

export interface AdminMessageSendRequest {
    fromUserId: string;
    toUserId: string;
    message?: string | undefined;
}

export interface MessageSendRequest {
    fromUserId: string;
    message?: string | undefined;
}

export interface AdminChatUserUpdateRequest {
    dialogId: string;
    lastMessageId?: string | undefined;
    lastMessageTime?: Date | undefined;
}

export interface AdminContactUsHelper {
    contactUs?: AdminContactUsResponse[] | undefined;
    paginator?: PaginatorResponse | undefined;
    isEmpty: boolean;
}

export interface AdminContactUsRequest {
    pageFilter?: AdminPageFilterRequest | undefined;
    type: ContactUsStateEnum;
}

export interface AdminContactUsUpdateRequest {
    id: string;
    managerComment?: string | undefined;
    state: ContactUsStateEnum;
}

export interface AdminCountryHelper {
    countries?: AdminCountryResponse[] | undefined;
    paginator?: PaginatorResponse | undefined;
    isEmpty: boolean;
}

export interface AdminCountryRequest {
    pageFilter?: AdminPageFilterRequest | undefined;
}

export interface AdminCountryAddOrUpdate {
    id: number;
    id1C?: string | undefined;
    name?: string | undefined;
    isActive: boolean;
}

export interface AdminCityHelper {
    cities?: AdminCityResponse[] | undefined;
    paginator?: PaginatorResponse | undefined;
    isEmpty: boolean;
}

export interface AdminCityRequest {
    pageFilter?: AdminPageFilterRequest | undefined;
    countryId: number;
}

export interface AdminCityAddOrUpdate {
    id: number;
    id1C?: string | undefined;
    name?: string | undefined;
    isActive: boolean;
    countryId: number;
}

export interface AdminDownloadInfoHelper {
    downloadInfo?: AdminDownloadInfoResponse[] | undefined;
    paginator?: PaginatorResponse | undefined;
    isEmpty: boolean;
}

export interface AdminDownloadInfoResponse {
    id: string;
    title?: string | undefined;
    stringKey?: string | undefined;
    image?: string | undefined;
    created: Date;
    updated?: Date | undefined;
    createdStr?: string | undefined;
    updatedStr?: string | undefined;
    isActive: boolean;
    files?: AdminDownloadInfoItemResponse[] | undefined;
}

export interface AdminDownloadInfoItemResponse {
    id: string;
    title?: string | undefined;
    image?: string | undefined;
    file?: string | undefined;
    stringKey?: string | undefined;
    created: Date;
    updated?: Date | undefined;
    createdStr?: string | undefined;
    updatedStr?: string | undefined;
    isActive: boolean;
    downloadInfoId: string;
    fileType?: string | undefined;
    fileSize: number;
}

export interface AdminDownloadInfoRequest {
    pageFilter?: AdminPageFilterRequest | undefined;
}

export interface AdminDownloadInfoItemHelper {
    downloadInfoItems?: AdminDownloadInfoItemResponse[] | undefined;
    paginator?: PaginatorResponse | undefined;
    isEmpty: boolean;
}

export interface AdminDownloadInfoItemRequest {
    pageFilter?: AdminPageFilterRequest | undefined;
}

export interface AdminRouteHelper {
    routes?: AdminRouteResponse[] | undefined;
    paginator?: PaginatorResponse | undefined;
    isEmpty: boolean;
}

export interface AdminRouteResponse {
    id: number;
    id1C?: string | undefined;
    isActive: boolean;
    days?: string | undefined;
    title?: string | undefined;
    time: Date;
    remainingMinutes: number;
    isCheck: boolean;
    isUser: boolean;
    created: Date;
    updated?: Date | undefined;
    storeId: number;
    store?: AdminStoreResponse | undefined;
    type: RouteTypeEnum;
    sectorId: number;
    sectorTitle?: string | undefined;
}

export interface AdminStoreResponse {
    id: number;
    id1C?: string | undefined;
    name?: string | undefined;
    adress?: string | undefined;
    latitude?: string | undefined;
    longtitude?: string | undefined;
    description?: string | undefined;
    isActive: boolean;
    stringKey?: string | undefined;
    position: number;
    showInFooter: boolean;
    image?: string | undefined;
    type: StoreTypeEnum;
    phones?: string[] | undefined;
    created: Date;
    updated?: Date | undefined;
    cityId?: number | undefined;
    city?: AdminCityResponse | undefined;
    frame?: string | undefined;
    descriptionHtml?: string | undefined;
}

export interface AdminRouteRequest {
    pageFilter?: AdminPageFilterRequest | undefined;
}

export interface AdminRouteAddOrUpdate {
    id: number;
    id1C?: string | undefined;
    isActive: boolean;
    days?: string | undefined;
    title?: string | undefined;
    time: Date;
    remainingMinutes: number;
    storeId: number;
}

export interface AdminSectorHelper {
    sectors?: AdminSectorResponse[] | undefined;
    paginator?: PaginatorResponse | undefined;
    isEmpty: boolean;
}

export interface AdminSectorResponse {
    id: number;
    id1C?: string | undefined;
    title?: string | undefined;
    type: RouteTypeEnum;
    typeStr?: string | undefined;
    created: Date;
    updated?: Date | undefined;
    routes?: AdminRouteResponse[] | undefined;
}

export interface AdminSectorRequest {
    pageFilter?: AdminPageFilterRequest | undefined;
}

export interface AdminSectorAddOrUpdate {
    id: number;
    id1C?: string | undefined;
    title?: string | undefined;
    type: RouteTypeEnum;
    sectorIds?: number[] | undefined;
}

export interface AdminOptionHelper {
    options?: AdminOptionResponse[] | undefined;
    paginator?: PaginatorResponse | undefined;
    isEmpty: boolean;
}

export interface AdminOptionResponse {
    id: string;
    id1C?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    position: number;
    isActive: boolean;
    parentId?: string | undefined;
    created: Date;
    updated?: Date | undefined;
    type: TypeOption;
    typeStr?: string | undefined;
    values?: AdminOptionValueResponse[] | undefined;
}

export interface AdminOptionValueResponse {
    id: string;
    id1C?: string | undefined;
    value?: string | undefined;
    position: number;
    isActive: boolean;
    dependId?: string | undefined;
    created: Date;
    updated?: Date | undefined;
    optionId: string;
}

export interface AdminOptionRequest {
    pageFilter?: AdminPageFilterRequest | undefined;
}

export interface AdminOptionHelperResponse {
    allOptions?: AdminOptionResponse[] | undefined;
    option?: AdminOptionResponse | undefined;
}

export interface AdminOptionAddOrUpdate {
    id?: string | undefined;
    id1C?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    isActive: boolean;
    parentId?: string | undefined;
    type: TypeOption;
}

export interface AdminOptionValueRequest {
    pageFilter?: AdminPageFilterRequest | undefined;
    optionId?: string | undefined;
}

export interface AdminOptionValueAddOrUpdate {
    id?: string | undefined;
    id1C?: string | undefined;
    value?: string | undefined;
    isActive: boolean;
    dependId?: string | undefined;
    optionId: string;
}

export interface AdminOrderHelper {
    orders?: AdminOrderResponse[] | undefined;
    paginator?: PaginatorResponse | undefined;
    isEmpty: boolean;
}

export interface AdminOrderResponse {
    id: number;
    id1C?: string | undefined;
    isPaid: boolean;
    isReject: boolean;
    address?: string | undefined;
    priceProducts: number;
    commentOnOrder?: string | undefined;
    currency?: UserCurrencyResponse | undefined;
    currencyEnum: UserCurrencyEnum;
    typeStr?: string | undefined;
    type: OrderNumberType;
    phone?: string | undefined;
    currencyCode?: string | undefined;
    dateOfOrder: Date;
    created: Date;
    updated?: Date | undefined;
    createdStr?: string | undefined;
    updatedStr?: string | undefined;
    dateOfOrderStr?: string | undefined;
    userId?: string | undefined;
    user?: UserProfileResponse | undefined;
    orderStatus?: string | undefined;
    orderStatusEnum: OrderStateEnum;
    storeId?: number | undefined;
    newStoreId?: number | undefined;
    deliveryId: number;
    paymentTypeId: number;
    orderProducts?: AdminOrderProdcutResponse[] | undefined;
    orderHistories?: AdminOrderHistoryResponse[] | undefined;
    invoices?: AdminInvoiceResponse[] | undefined;
    permittedRoutes?: AdminRouteResponse[] | undefined;
    userAddresses?: string[] | undefined;
    adminCommentOnOrder?: string | undefined;
}

export interface AdminOrderProdcutResponse {
    id: string;
    count: number;
    pricePerItem: number;
    pricePerItemFull: number;
    discount: number;
    priceTotal: number;
    created: Date;
    updated?: Date | undefined;
    productId: string;
    productId1C?: string | undefined;
    product?: AdminProductResponse | undefined;
    orderId: number;
    storeId: number;
    store?: AdminStoreResponse | undefined;
    productPrice?: AdminProductPriceHelper | undefined;
}

export interface AdminProductResponse {
    id: string;
    id1C?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    fullDescription?: string | undefined;
    isShowMain: boolean;
    isActive: boolean;
    isNew: boolean;
    isDiscount: boolean;
    isBestseller: boolean;
    articul?: string | undefined;
    articulClean?: string | undefined;
    articulBrand?: string | undefined;
    stringKey?: string | undefined;
    discount: number;
    seoTitle?: string | undefined;
    seoDescription?: string | undefined;
    seoKeywords?: string | undefined;
    imageIcon?: string | undefined;
    crossNumber?: string | undefined;
    created: Date;
    updated?: Date | undefined;
    unitId: number;
    unit?: AdminUnitResponse | undefined;
    brandId?: number | undefined;
    brand?: AdminBrandResponse | undefined;
    analogs?: AdminProductAnalogHelper[] | undefined;
    storeProductCount?: AdminStoreProductCountHelper[] | undefined;
    categoryProducts?: AdminCategoryProductHelper[] | undefined;
    optionValueProducts?: AdminProductOptionValueHelper[] | undefined;
    productPrice?: AdminProductPriceHelper | undefined;
    images?: AdminProductImageHelper[] | undefined;
}

export interface AdminUnitResponse {
    id: number;
    id1C?: string | undefined;
    name?: string | undefined;
    stringKey?: string | undefined;
    symbol?: string | undefined;
    created: Date;
    updated?: Date | undefined;
}

export interface AdminProductAnalogHelper {
    id: string;
    productId: string;
    crossNumber?: string | undefined;
    productTitle?: string | undefined;
    created: Date;
    updated?: Date | undefined;
}

export interface AdminStoreProductCountHelper {
    id?: number | undefined;
    count: number;
    delivery?: string | undefined;
    isDelivery: boolean;
    storeId: number;
    storeTitle?: string | undefined;
    productId: string;
    created: Date;
    updated?: Date | undefined;
}

export interface AdminCategoryProductHelper {
    productId?: string | undefined;
    productTitle?: string | undefined;
    categoryId: string;
    categoryTitle?: string | undefined;
}

export interface AdminProductOptionValueHelper {
    productId: string;
    optionValuesId: string;
    optionId: string;
    productTitle?: string | undefined;
    optionValueTitle?: string | undefined;
    optionTitle?: string | undefined;
}

export interface AdminProductPriceHelper {
    id: string;
    created: Date;
    productId: string;
    productTitle?: string | undefined;
    discountStart?: Date | undefined;
    discountEnd?: Date | undefined;
    rublePrice: number;
    rublePriceDiscount: number;
    dollarPrice: number;
    dollarPriceDiscount: number;
    discountActive: boolean;
}

export interface AdminProductImageHelper {
    id: string;
    id1C?: string | undefined;
    smallUrl?: string | undefined;
    mediumUrl?: string | undefined;
    originalUrl?: string | undefined;
    isMain: boolean;
    productId: string;
    productTitle?: string | undefined;
    created: Date;
    updated?: Date | undefined;
}

export interface AdminOrderHistoryResponse {
    id: string;
    created: Date;
    updated?: Date | undefined;
    orderId: number;
    orderStatus?: string | undefined;
}

export interface AdminInvoiceResponse {
    id: number;
    sum: number;
    info?: string | undefined;
    isPaid: boolean;
    created: Date;
    updated?: Date | undefined;
    userId: string;
    ePaymentId: number;
    paymentResponse?: string | undefined;
    offerId: number;
    typeOffer: TypeOffer;
    typeOfferStr?: string | undefined;
    currncyCode?: string | undefined;
}

export interface AdminOrderRequest {
    pageFilter?: AdminPageFilterRequest | undefined;
}

export interface AdminOrderAddOrUpdate {
    id: number;
    id1C?: string | undefined;
    isPaid: boolean;
    address?: string | undefined;
    priceProducts: number;
    commentOnOrder?: string | undefined;
    routeTime?: Date | undefined;
    routeId?: number | undefined;
    orderNumberType: OrderNumberType;
    phone?: string | undefined;
    currency: UserCurrencyEnum;
    dateOfOrder: Date;
    userId?: string | undefined;
    paymentTypeId: number;
    deliveryId: number;
    orderStatus: OrderStateEnum;
    storeId?: number | undefined;
    newStoreId?: number | undefined;
    adminCommentOnOrder?: string | undefined;
    orderProducts?: AdminOrderProductAddOrUpdate[] | undefined;
}

export interface AdminOrderProductAddOrUpdate {
    id: string;
    count: number;
    pricePerItem: number;
    pricePerItemFull: number;
    discount: number;
    priceTotal: number;
    productId: string;
    storeId: number;
}

export interface AdminOrderCurrencyChangeRequest {
    products?: AdminOrderProductAddOrUpdate[] | undefined;
    currency: UserCurrencyEnum;
    targetUserId?: string | undefined;
    orderId: number;
}

export interface AdminPageHelper {
    pages?: AdminPageResponse[] | undefined;
    paginator?: PaginatorResponse | undefined;
    isEmpty: boolean;
}

export interface AdminPageResponse {
    id: number;
    name?: string | undefined;
    content?: string | undefined;
    metaTitle?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    created: Date;
    updated?: Date | undefined;
    createdStr?: string | undefined;
    updatedStr?: string | undefined;
}

export interface AdminPageRequest {
    pageFilter?: AdminPageFilterRequest | undefined;
}

export interface AdminPageUpdateRequest {
    id: number;
    content?: string | undefined;
    metaTitle?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
}

export interface AdminPartnerHelper {
    partners?: AdminPartnerResponse[] | undefined;
    paginator?: PaginatorResponse | undefined;
    isEmpty: boolean;
}

export interface AdminPartnerResponse {
    id: number;
    id1C?: string | undefined;
    isActive: boolean;
    name?: string | undefined;
    description?: string | undefined;
    image?: string | undefined;
    url?: string | undefined;
    country?: string | undefined;
    created: Date;
    updated?: Date | undefined;
    createdStr?: string | undefined;
    updatedStr?: string | undefined;
    position: number;
}

export interface AdminPartnerRequest {
    pageFilter?: AdminPageFilterRequest | undefined;
}

export interface AdminPhoneCountryResponse {
    id: number;
    phoneCountryEnumCode: PhoneCountryEnum;
    phoneCountryCode?: string | undefined;
    name?: string | undefined;
    length?: string | undefined;
    code?: string | undefined;
    isActive: boolean;
    created: Date;
    updated?: Date | undefined;
}

export interface AdminPhoneCountryUpdateRequest {
    id: number;
    name?: string | undefined;
    length?: string | undefined;
    code?: string | undefined;
    isActive: boolean;
}

export interface AdminPriceLevelHelper {
    priceLevels?: AdminPriceLevelResponse[] | undefined;
    paginator?: PaginatorResponse | undefined;
    isEmpty: boolean;
}

export interface AdminPriceLevelResponse {
    id: number;
    id1C?: string | undefined;
    value: number;
    title?: string | undefined;
    discount: number;
    created: Date;
    updated?: Date | undefined;
    priceLevelBrands?: AdminPriceLevelBrandResponse[] | undefined;
}

export interface AdminPriceLevelBrandResponse {
    id: string;
    brandId: number;
    brand?: AdminBrandResponse | undefined;
    priceLevelId: number;
    discount: number;
    created: Date;
    updated?: Date | undefined;
}

export interface AdminPriceLevelRequest {
    pageFilter?: AdminPageFilterRequest | undefined;
}

export interface AdminPriceLevelAddOrUpdate {
    id: number;
    id1C?: string | undefined;
    title?: string | undefined;
    priceLevelBrands?: AdminPriceLevelBrandRequest[] | undefined;
}

export interface AdminPriceLevelBrandRequest {
    brandId: number;
    discount: number;
}

export interface AdminProductHelper {
    products?: AdminProductResponse[] | undefined;
    paginator?: PaginatorResponse | undefined;
    isEmpty: boolean;
}

export interface AdminProductRequest {
    pageFilter?: AdminPageFilterRequest | undefined;
    isAll: boolean;
    isActive: boolean;
    isNew: boolean;
    isBestseller: boolean;
    isDiscount: boolean;
    isShowMain: boolean;
}

export interface AdminProductAddOrUpdate {
    id?: string | undefined;
    id1C?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    fullDescription?: string | undefined;
    isShowMain: boolean;
    isActive: boolean;
    isNew: boolean;
    isDiscount: boolean;
    isBestseller: boolean;
    articul?: string | undefined;
    seoTitle?: string | undefined;
    seoDescription?: string | undefined;
    seoKeywords?: string | undefined;
    brandId?: number | undefined;
    crossNumber?: string | undefined;
    unitId: number;
    storeProductCount?: StoreProductCountAddOrUpdate[] | undefined;
    categoryIds?: string[] | undefined;
    optionValueProductIds?: string[] | undefined;
    productPrice?: AdminProductPriceAddOrUpdate | undefined;
}

export interface StoreProductCountAddOrUpdate {
    storeId: number;
    count: number;
    delivery?: string | undefined;
}

export interface AdminProductPriceAddOrUpdate {
    discountStart?: Date | undefined;
    discountEnd?: Date | undefined;
    rublePrice: number;
    rublePriceDiscount: number;
    dollarPrice: number;
    dollarPriceDiscount: number;
}

export interface AdminProductArticulRequset {
    articul?: string | undefined;
    targetUserId?: string | undefined;
    currency: UserCurrencyEnum;
    orderId: number;
}

export interface SocialNetworkRequest {
    id: number;
    url?: string | undefined;
    isActive: boolean;
}

export interface AdminBadgeResponse {
    mailing: number;
    contactUs: number;
    sto: number;
    order: number;
}

export interface AdminMainHelper {
    options?: AdminOptionResponse[] | undefined;
    categories?: AdminCategoryParentHelper[] | undefined;
    brands?: AdminBrandResponse[] | undefined;
    units?: AdminUnitResponse[] | undefined;
    stores?: AdminStoreResponse[] | undefined;
    sectors?: AdminSectorResponse[] | undefined;
    routes?: AdminRouteResponse[] | undefined;
    priceLevels?: AdminPriceLevelResponse[] | undefined;
    paymentTypes?: AdminPaymentTypeResponse[] | undefined;
    deliveries?: AdminDeliveryResponse[] | undefined;
    countries?: AdminCountryResponse[] | undefined;
    marks?: AdminTecDocMarkResponse[] | undefined;
    models?: AdminTecDocModelResponse[] | undefined;
    modifications?: AdminTecDocModificationResponse[] | undefined;
    tecDocBrands?: TecDocBrandResponse[] | undefined;
}

export interface AdminPaymentTypeResponse {
    id: number;
    id1C?: string | undefined;
    name?: string | undefined;
    stringKey?: string | undefined;
    isActive: boolean;
    created: Date;
    updated?: Date | undefined;
}

export interface AdminDeliveryResponse {
    id: number;
    name?: string | undefined;
    stringKey?: string | undefined;
    isActive: boolean;
    created: Date;
    updated?: Date | undefined;
}

export interface AdminTecDocMarkResponse {
    name?: string | undefined;
    fullDescription?: string | undefined;
    matchCode?: string | undefined;
    id: string;
    id1C?: string | undefined;
    tecDocId: number;
    isActive: boolean;
    created: Date;
    updated?: Date | undefined;
    models?: AdminTecDocModelResponse[] | undefined;
}

export interface AdminTecDocModelResponse {
    description?: string | undefined;
    fullDescription?: string | undefined;
    matchCode?: string | undefined;
    constructionInterval?: string | undefined;
    id: string;
    id1C?: string | undefined;
    tecDocId: number;
    tecDocManufacturerId: number;
    isActive: boolean;
    created: Date;
    updated?: Date | undefined;
    vehicleId: string;
    vehicleName?: string | undefined;
    modifications?: AdminTecDocModificationResponse[] | undefined;
}

export interface AdminTecDocModificationResponse {
    name?: string | undefined;
    fullName?: string | undefined;
    interval?: string | undefined;
    engineCodes?: string | undefined;
    powerKw?: string | undefined;
    powerPs?: string | undefined;
    capacityCcm?: string | undefined;
    bodyType?: string | undefined;
    fuelType?: string | undefined;
    matchCode?: string | undefined;
    id: string;
    id1C?: string | undefined;
    tecDocId: number;
    tecDocModelCarId: number;
    vehicleName?: string | undefined;
    isActive: boolean;
    created: Date;
    updated?: Date | undefined;
    modelVehicleId: string;
}

export interface AdminStoHelper {
    contactUs?: AdminStoResponse[] | undefined;
    paginator?: PaginatorResponse | undefined;
    isEmpty: boolean;
}

export interface AdminStoRequest {
    pageFilter?: AdminPageFilterRequest | undefined;
    status: StoStatusEnum;
}

export interface AdminStoUpdateRequest {
    id: string;
    time?: string | undefined;
    date: Date;
    commentManager?: string | undefined;
    status: StoStatusEnum;
    rejectReason?: string | undefined;
}

export interface AdminStoreHelper {
    strores?: AdminStoreResponse[] | undefined;
    paginator?: PaginatorResponse | undefined;
    isEmpty: boolean;
}

export interface AdminStoreRequest {
    pageFilter?: AdminPageFilterRequest | undefined;
}

export interface AdminStoreHelperResponse {
    store?: AdminStoreResponse | undefined;
    countries?: AdminCountryResponse[] | undefined;
}

export interface AdminTecDocMarkHelper {
    marks?: AdminTecDocMarkResponse[] | undefined;
    paginator?: PaginatorResponse | undefined;
    isEmpty: boolean;
}

export interface AdminTecDocMarkRequest {
    pageFilter?: AdminPageFilterRequest | undefined;
}

export interface AdminTecDocModelHelper {
    models?: AdminTecDocModelResponse[] | undefined;
    paginator?: PaginatorResponse | undefined;
    isEmpty: boolean;
}

export interface AdminTecDocModelRequest {
    pageFilter?: AdminPageFilterRequest | undefined;
}

export interface AdminTecDocModificationHelper {
    modifications?: AdminTecDocModificationResponse[] | undefined;
    paginator?: PaginatorResponse | undefined;
    isEmpty: boolean;
}

export interface AdminTecDocModificationRequest {
    pageFilter?: AdminPageFilterRequest | undefined;
}

export interface AdminTecDocUpdateCarActivity1C {
    id1C?: string | undefined;
    isActive: boolean;
}

export interface AdminTecDocMarkAddOrUpdate {
    name?: string | undefined;
    fullDescription?: string | undefined;
    matchCode?: string | undefined;
    id?: string | undefined;
    id1C?: string | undefined;
    tecDocId: number;
    isActive: boolean;
}

export interface AdminTecDocModelAddOrUpdate {
    description?: string | undefined;
    fullDescription?: string | undefined;
    matchCode?: string | undefined;
    constructionInterval?: string | undefined;
    id?: string | undefined;
    id1C?: string | undefined;
    tecDocId: number;
    tecDocManufacturerId: number;
    isActive: boolean;
    vehicleId: string;
}

export interface AdminTecDocModificationAddOrUpdate {
    name?: string | undefined;
    fullName?: string | undefined;
    interval?: string | undefined;
    engineCodes?: string | undefined;
    powerKw?: string | undefined;
    powerPs?: string | undefined;
    capacityCcm?: string | undefined;
    bodyType?: string | undefined;
    fuelType?: string | undefined;
    matchCode?: string | undefined;
    id?: string | undefined;
    id1C?: string | undefined;
    tecDocId: number;
    tecDocModelCarId: number;
    isActive: boolean;
    modelVehicleId: string;
}

export interface AdminUnitHelper {
    units?: AdminUnitResponse[] | undefined;
    paginator?: PaginatorResponse | undefined;
    isEmpty: boolean;
}

export interface AdminUnitRequest {
    pageFilter?: AdminPageFilterRequest | undefined;
}

export interface AdminUnitAddOrUpdate {
    id: number;
    id1C?: string | undefined;
    name?: string | undefined;
    symbol?: string | undefined;
}

export interface AdminUserHelper {
    users?: AdminUserResponse[] | undefined;
    paginator?: PaginatorResponse | undefined;
    isEmpty: boolean;
}

export interface AdminUserResponse {
    id: string;
    id1C?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    middleName?: string | undefined;
    name?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    comment?: string | undefined;
    phonePrefix?: string | undefined;
    userCurrency: UserCurrencyEnum;
    userType: UserTypeEnum;
    created: Date;
    updated?: Date | undefined;
    resetPassword?: Date | undefined;
    mainRole?: string | undefined;
    createMethod?: string | undefined;
    userUtc: number;
    oldLogin1C?: string | undefined;
    emailSended: boolean;
    cityId?: number | undefined;
    city?: AdminCityResponse | undefined;
    priceLevelId?: number | undefined;
    priceLevel?: AdminPriceLevelResponse | undefined;
    phoneCountryId: number;
    isAccountingPermission: boolean;
    phoneCountry?: AdminPhoneCountryResponse | undefined;
    userBalanceId?: number | undefined;
    userBalance?: AdminUserBalanceResponse | undefined;
    userModificationVehicles?: AdminUserModificationVehicleResponse[] | undefined;
    sectors?: AdminUserSectorHelper[] | undefined;
    stores?: AdminUserStoreHelper[] | undefined;
    addresses?: string[] | undefined;
    role: RoleEnum;
}

export interface AdminUserBalanceResponse {
    userId?: string | undefined;
    balance: number;
    updated?: Date | undefined;
}

export interface AdminUserModificationVehicleResponse {
    id: string;
    vinCode?: string | undefined;
    name?: string | undefined;
    isMain: boolean;
    created: Date;
    updated?: Date | undefined;
    userId: string;
    modificationVehicleId: string;
}

export interface AdminUserSectorHelper {
    sectorId: number;
    sector?: AdminSectorResponse | undefined;
}

export interface AdminUserStoreHelper {
    storeId: number;
    store?: AdminStoreResponse | undefined;
}

/** 0 = Admin 1 = Manager 2 = Customer */
export enum RoleEnum {
    Admin = 0,
    Manager = 1,
    Customer = 2,
}

export interface AdminUserRequest {
    pageFilter?: AdminPageFilterRequest | undefined;
}

export interface AdminUserAddOrUpdate {
    id: string;
    id1C?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    middleName?: string | undefined;
    email?: string | undefined;
    userCurrency: UserCurrencyEnum;
    userType: UserTypeEnum;
    isAccountingPermission: boolean;
    mainRole?: string | undefined;
    userUtc: number;
    oldLogin1C?: string | undefined;
    cityId?: number | undefined;
    priceLevelId?: number | undefined;
    phoneCountryId: number;
    balance: number;
    phone?: string | undefined;
    sectors?: number[] | undefined;
    stores?: number[] | undefined;
    addresses?: string[] | undefined;
    role: RoleEnum;
}

export interface Data {

    [key: string]: any;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}
